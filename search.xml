<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jpa-model]]></title>
    <url>%2F2019%2F04%2F13%2FJpa-model%2F</url>
    <content type="text"><![CDATA[记录Java persistence常用注射 基础@Table name : 表名 uniqueConstraints: uniqueConstraints={@UniqueConstraint(columnNames = {“columnName”,”columnNameTwo”})}, 该参数表示不可重复的列名,注意和@Column(unique=true的区别 @Id 标名为主键 一般配合@GeneratedValue()使用 @GeneratedValue strategy 增长方法 TABLE SEQUENCE IDNETITY AUTO]]></content>
      <categories>
        <category>Sring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F04%2F11%2Fredis%2F</url>
    <content type="text"><![CDATA[1读《redis in action》笔记 redis事务事务型流水线关键指令 MULTI:声明事务 WATCH: 在事务过程中观察指定键值 EXEC:执行事务 DISCARD: 在WATCH后执行，取消WATCH和清空已经进入事务队列的命令 非事务型流水线 1conn.pipeline(False) 当命令的执行结果不影响另外一个命令输入时，可以不使用MULTI和EXEC执行事务 减少了应用程序和redis之间的通讯次数,可以提升redis性能 redis 性能测试 123redis-benchmark -c 1 -q# -c client 只选定一个client进行测试# -q简化输出 性能问题 单个客户端达到redis-bench 的50%-60% 的性能 不使用流水线的预期 性能达到25%-30% 对于每个指令都使用了新的连接构建应用程序组件自动补全简单自动补全 维护一个列表 在push联系人之前先删除该联系人，将其放在最前面 减枝利用有序集合的特性 利用有序集合的特性来减少排序的开销 12345678127.0.0.1:6379&gt; zrange complete 0 -11) "abc"2) "abc`"3) "abcd"4) "abce"5) "abcz"6) "abc&#123;"7) "c" 通过讲每个元素的分值设置为0，则通过ASCII编码排序 其他的语言原理是一样的构建分布式锁 简易锁 1234567891011121314import timeimport uuiddef acquire_lock(conn,lockname,acquire_timeout= 10): identifier = str(uuid.uuid4()) end = time.time()+acquire_lock while time.time()&lt;end: if conn.setnx('lock:'+lockname,identifier): return identifier time.sleep(0.01) return False''' 问题 1.当前锁失效后会有很多线程去请求锁，会出现多个线程获取锁的情况 2.锁的持有者崩溃后不会自动释放''' 带超时的锁 123456789101112131415161718import uuidimport mathimport time def acquire_lock_with_timeout(conn,lockname,acquire_time = 10,lock_timeout=10):identifier = str(uuid.uuid4())lockname ='lock:'+ locknamelock_timeout = int(math.ceil(lock_timeout))end = time.time()+acquire_timewhile time.time()&lt;end: if conn.setnx(lockname,identifier): conn.expire(lockname,lock_timeout) return identifier elif not conn.ttl(lockname): #防止持有锁的线程崩溃 conn.expire(lockname,lock_timeout) time.sleep(0.001)return False 锁的几个关注点 锁的持有者 锁持有者崩溃 锁的持有者超时计数信号量]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithms]]></title>
    <url>%2F2019%2F03%2F18%2Falgorithms%2F</url>
    <content type="text"><![CDATA[​ 复习算法，还没有看完，先总结一波（算法怎么看得完QAQ 排序冒泡排序 这个应该是最简单的了，直接贴代码好了 插入排序 类似于抽牌排序的过程 归并排序 借用二分的思想，当分成只有一个元素的片段时就已经是排好序了 合并就类似于链表的合并，但是需要额外开辟空间 堆排序 buildTree，从右边数第一个叶子结点的父节点开始建树， 123456789101112131415161718for(int i=nums.length/2-1;i&gt;=0;i--)&#123; heapify(i); &#125;public void maxHeapify(int index)&#123; int left = 2*index +1; int right = 2*index+2; int max = index; if(left&lt;this.heapSize&amp;&amp; num[left]&gt;num[max])&#123; max = left; &#125; if(right&lt;this.heapSize&amp;&amp; num[right]&gt; num[max])&#123; max = right; &#125; if(max!=i)&#123; swap(max,i) maxHeapify(max) &#125;&#125; ​ 建堆完毕后，取出最大值后重新建堆即可 123456789public void sort()&#123; maxTreeBuild(); for(int i = num.length-1;i&gt;=0;i++)&#123; this.heapSize-- swap(i,0); maxHeapify(0); &#125;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReviewQuestion]]></title>
    <url>%2F2019%2F02%2F28%2FJavaReviewQuestion%2F</url>
    <content type="text"><![CDATA[一些常见的Java面试问题 操作系统中 heap 和 stack 的区别 栈:由操作系统自动分配释放，存放函数的参数值，局部变量的值等。 堆:一般由程序员分配释放，若程序员不释放，程序结束后OS自动回收 栈使用的是一级缓存，堆使用的是二级缓存。什么是基于注解的切面实现 使用注解的方式实现面向切面编程(AOP),可以在某个方法执行或者执行后插入一些代码什么是 对象/关系 映射集成模块 对象关系映射(Object Relational Mapping)即:ORM。 将面向对象程序中的对象持久化到关系数据库中。Java反射机制 Java反射机制是在运行状态中，对于任意一个实体类，都能够获得类的所有属性和方法 对于对象，可以调用它的任意方法和属性。DataBase索引的一篇文章ACID 数据库事务四大的特性 原子性(Atomicity) 一致性(Consistency) 独立性(Isolation) 持久性(Durability)索引的类型 哈希索引 B_tree Full-text索引主键和唯一索引的区别 主键是一种约束，唯一索引是一种索引 主键唯一标识一列，索引用于优化查找索引的优点 加快了数据检索的速度，减少查询时间索引的缺点 创建索引需要耗费时间 索引需要占据物理空间 mysql事务级别 read uncommitted –&gt;脏读 read commited –&gt;不可重复读，防脏读，存在幻读 repeatable read,用户当前会话可以重复读，就是每次读取的结果都相同，不管其他事务有没有提交 serializable 串行化join 博客mysql引擎 MyISAM较高的插入，查询速度，担不支持事务，B+tree作为索引结构，索引文件仅仅保存地址 InnoDB,支持事务，行锁定和外键。数据文件本身就是索引文件 Memory储存引擎，内存 ArchiveBTree和B+TreeNetworkBS和CS的联系和区别 C/S:Client/Server,一般用于小范围的网络环境 B/S:Brower/Server，建立在广域网的基础上Cookie 和 Session的区别 Cookie是服务器在本地机器存储的小段文本并随每段请求发送至同一个服务器。 Session是一种服务器端的机制，服务器使用的一种类似于散列表的结构，当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id),保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险 JWT可以替代session，cookie的传统认证方式fail-fast 与 fail-safe 机制有什么区别 Collection类在遍历时，被修改的时候会出现（单线程和多线程都可能出现）CurrentModificationException fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException GET和POST的区别 GET是向服务器获取资源，只能通过Url的queryString来限制 而POST是将参数放在request body里 GET会退是无害的，POST会从新提交请求 GET只支持url编码，POST支持多种编码方式 Get只接受ASCII字符，POST没有限制 GET有长度限制 开源中国社区的一篇文章 [http://www.oschina.net]interface和abstract类的区别 抽象类和接口都不能够被实例化，但可以定义抽象类和接口类型的应用 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类 法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 interface abstract类 implement实现接口 extends 继承类 不能定义构造器 可以有构造器 方法全部都是抽象方法 可以有抽象方法和具体方法 定义的成员变量实际上都是常量 可以定义成员变量 成员全是public 成员可以是private，默认，protected，public IOC的优点是什么 降低计算机代码之间的耦合度。 资源集中管理，实现资源的可配置和易管理IO 和 NIO的区别，NIO优点 IO是面向流的，而NIO是面对缓冲区的。 cnblog的一篇文章什么是竞态条件，死锁？ 举个例子说明。 单两个线程竞争同一个资源时，如果对资源的访问顺序敏感，就称为存在竞态条件。 导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。临界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现 如:代码中对一个类变量进行add操作就可能出现问题。(+不是一个原子性的操作) 死锁:两个线程都等待对方释放相应的对象锁MVC的各个部分都有那些技术来实现?如何实现? M：hibernate/mybatis/ibatis C：severlet/struts/spring action V：jsp/FreeMarker/tails/taglib/EL/VelocityRPC 通信和 RMI 区别 博客 WEB容器 又是一篇好文章servlet的生命周期 init():只被调用一次，servlet创建的时候被调用 service(): 处理来自客户端的请求 destroy():用来关闭数据库，停止后台线程等清理活动。 Java正则表达式 import java.util.regex.*; 正则表达式 什么是懒加载（Lazy Loading） 即延迟加载 减少网络压力 伪递归 在函数执行的最后执行自身，将得到的结果交个子函数就行了，自身计算已经完成; Java不支持自动优化尾递归 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection IOC是一种编程设计原则，减少代码之间的耦合度，借助第三方实现依赖的注入。 IOC是思想，依赖注入是设计模式 Java内存和JVM模型 转载自Hollis finalize关键字 finalize()方法: 在垃圾收集器将对象从内存中清楚出去之前做必要的清理工作(只有在该对象没有被引用时调用，且只执行一次 finalize()时Object对象的方法，但是没有实现，可以Override; volatile 可见性，但不具备原子性，适用于读操作远大于写操作 volatile修饰的变量被修改时所有使用到此变量的线程都立即能够看到变化。 内存屏蔽，防止指令重排 transient 只能修饰成员变量！！！ 用户自定义的类变量，需要实现serilizable接口才能被transient修饰 被transient修饰的变量不能被序列化 equal和‘==’区别 如果对象是从超类Object继承的equal方法时，两者完全等效。 要比较内容需要自己重写equal内容 Java switch 语句可以用的类型 byte，char, short,int以及他们的包装类 Long, float,double,boolean以及他们的包装类时不可以的。 枚举类型可以用于switch,但是Java5.0（1.5）版本以上 a = a + b 与 a += b 的区别？ a = a+b,不会进行类型转化，为了避免出错需要显式类型转换 a+=b会进行转化。 SpringjavaSpring bean的管理方式 Singleton :每个容器只有一个bean实例 prototype :为每一个bean请求提供一个实例 request : 为每个请求创建一个实例 session :为每个session global-sessionSpring注解的方式 基于xml Java配置类 注解Spring的生命周期 实例化 填充属性 调用BeanNameAware的setBeanName()方法 调用BeanFactoryAware的setBeanFactory() 调用ApplicationContextAware的setApplicationContext()方法 BeanProcessor的预初始化方法 调用InitializingBean的afterPropertiesSet() 调用自定义的初始化方法 调用BeanPostProcessor的初始化方法 调用DisposableBean的destroy()方法 调用自定义的销毁方法 Linux查看当前系统启动时间 top w uptime fg,bg,ctrl+z,jobs fg +作业号，将后台程序调度到前台 bg 与fg相反 ctrl+z将程序挂起 jobs查看正在运行的任务tar -c:compress，打包 -x:extract, 提取 -g:gzip，提取或压缩 -j:bzip2，提取或压缩 -v:verbose(详细)，显示指令执行过程 -f:指定提取或压缩后的文件名以及位置软链接和硬链接 硬链接和文件本身的inode号是一样的 相当于软链接是保存链一个绝对路径 多进程Linux查看进程命令 processes Statistic ps -aux 查看系统所有的进程 ps -IA 查看所有系统的数据 pa axif 连通部分进程树状态 pstree top###进程的状态 创建 就绪 阻塞 执行 终止进程间通讯 信号量 信号 管道 socket 消息队列 共享内存(最快) 文件锁进程间的比较 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 进程和线程的区别 进程是操作系统资源分配的基本单位， 而线程是任务调度和执行的基本单位 进程有独立的代码和数据空间，线程没有，线程切换开销小锁锁的种类 synchronized锁 互斥锁: 一次只允许一个线程进入被锁住的代码块 作用对象：方法块，代码块 内置锁/监视器锁，Java每一个对象都有一个内置锁，synchronized使用的是对象内置锁来锁定代码块 可见行，原子性 monitorenter, monitorexit 修饰静态变量获得的是类锁，其他是对象锁，对象锁和类锁是不冲突的 可重入: 锁的持有者是“线程” 释放: 不会出现死锁，自动释放锁，或者异常时会自动释放 乐观锁&amp;&amp;悲观锁 乐观锁：在使用数据时候不会添加锁 CAS(Java Autmtic 类) 悲观锁: 在使用数据时不管怎么样先加锁数据库连接池##网络协议ping ICMP(internet Control Message Protocol)http和https的区别 http = http+ssl http端口80，https端口443 http为明文传输 https过程：* 客户端请求公钥，同时验证公钥 * 验证成功，客户端通过公钥加密客户端的生成的随机值，通过这个随机值进行加密解密 https会是页面加载时间延长50%，增加10%～20%的耗电TCP 三次握手目的：信息对等和防止超时; 四次握手目的 TCP连接断开过程：1、客户端TCP模块在收到应用程序的通知后，发送FIN，seq=x。2、服务器收到FIN报文段，发送ACK，确认号=x+1，并且通知应用程序客户端关闭了连接。客户端收到ACK报文段。3、服务器端的应用程序通知TCP关闭连接，服务器端TCP发送FIN+ACK，seq=y，确认号=x+1（这里ACK只是一般性的捎带ACK，TCP总是这样，以增强健壮性，反正也不费力气，从原理上说，对连接断开不是必须的）。4、客户端收到FIN+ACK报文段后，发送ACK，确认号y+1。服务器收到ACK报文段后，连接断开。 第二步是不能省略的 因为，第二步中，服务器端通知应用程序并获得反馈信息可能需要可观的时间，这可能涉及人机交互操作，也可能服务器应用层暂时还不想关闭连接。第二步结束后，服务器还可以继续通过这条连接发送数据给客户端，客户端已经不能发送数据了，但是仍然可以回复ACK。第二步中服务器立即发送确认是为了防止客户端重传FIN报文。jdbc连接代码1234567891011121314151617String url="jdbc:mysql://localhost:3306/dbname?useSSL=false";String user="root";String password="password";String Driver="com.mysql.jdbc.dirver";try&#123; Class.forName(Driver); Connection conn = DriveManager.getConnecttion(url,user,paswword); Statement st = conn.createStatement(); ResultSet rs = st.excuteQuery(sql); //sql为sql的字符串形式 String sql = "UPDATE EMPLOYEES SET SALARY = ? WHERE ID = ? " PrepareStatement psmt = conn.PrepareStatement(sql); psmt.setInt(index,value); psmt.setString(); psmt.excute();&#125; hashcode 默认为内存地址 在需要hashcode时，要重写equals和hashcode方法CDN原理 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。]]></content>
      <categories>
        <category>JavaForJob</category>
      </categories>
      <tags>
        <tag>JavaReview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[network]]></title>
    <url>%2F2019%2F02%2F27%2Fnetwork%2F</url>
    <content type="text"><![CDATA[计算机网络题目 IP地址类型 IP: 网络ID+主机ID A类地址 一个字节网络ID+3字节主机地址构成 网络地址最高位为 0 range: 1.0.0.0–126.0.0.0 B类地址 2个网络IP地址+2个主机地址 网络地址最高位为 10（即:128的二进制10000000) range:128.0.0.0–191.255,255,255 C类地址 3byte网络地址+1byte主机地址 最高位 110 range: 192.0.0.0–223.255.255.255 D类地址 广播地址保留地址 A类保留地址10.0.0.0–10.255.255.255 B类保留地址172.16.0.0–172.31.255.255 C类保留地址192.168.0.0–192.168.255.255广播地址 主机位置1 如果有子网隐码如：/17,则后17置为1;线材 双绞线Max:100m 同轴电缆:1000m]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview.md]]></title>
    <url>%2F2019%2F02%2F27%2FJavaReview-md%2F</url>
    <content type="text"><![CDATA[Java基础回顾 受检查异常(unchecked Exception),和运行异常(RunTimeException) (蓝色的为runtimeException) 反射 *public Method[] getDeclaredMethods()**返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。 public Method[] getMethods()返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法 数值计算 没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。 如: byte运算会转化成int; static关键字 被static修饰的变量或者方法不需要使用对象去访问，是属于类的，只要类被加载，就可以通过类名访问，是实例所共享的。 static方法不能访问类的非static变量（非static变量,没有实例对象的话实际上是没有被初始化的） static不会影响访问权限 抽象类 static方法不能被重写，如果子类 抽象类和接口抽象类 抽象类提供了继承的概念，它的出发点就是为了继承 接口是特殊的抽象类 抽象方法必须由子类来重写(即:声明了abstract的方法在抽象类中没有{ })，子类中不能有和父亲类相同的抽象方法 Abstract 和final，private不共戴天 子类必须重写父类所有的抽象方法 接口 比抽象类更加抽象。 默认为public 必须重写所有方法;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CodeLife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpringUsingAnnotation.md]]></title>
    <url>%2F2019%2F01%2F21%2FJavaSpringUsingAnnotation%2F</url>
    <content type="text"><![CDATA[JavaSpringUsingAnnotation 长篇大论之前​ 最近觉得用JavaSpring的xml配置WebApplication的不方便，于是尝试用UsingNoXML的方式去写了一个简单的SpringMVC RESTful 程序。（其实近几年来，Spring也在向NoXML的方向靠拢，SpringBoot可以说是极大地解放了生产力） 工具即生产力​ Idea是世界上最好的IDE(没有之一,不接受反驳)，建议使用Idea的Springinitializr去构建项目，可以省去很多不必要的烦恼。(这个项目并不是用Springinitiallizr建立的，所以踩了很多坑QAQ) 依赖1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;Benji&lt;/groupId&gt; &lt;artifactId&gt;SpringMvcUsingAnnotation&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!-- mongodb是最主要的坑，版本依赖以Spring-4.2.0 为分界线，不然会有冲突，Spring4.2以上建议至少使用spring-data-mongodb-1.9以上的版本--&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;1.10.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/project&gt; ps:Spring版本为4.3.18 config文件结构1234567891011121314151617181920212223242526272829303132333435.├── SpringMvcUsingAnnotation.iml├── lib├── out├── pom.xml├── src├── target└── websrc文件结构:├── main│ ├── java│ │ ├── Benji│ │ │ ├── Controllers│ │ │ │ ├── HomeHandler.java│ │ │ │ ├── RestfulController.java│ │ │ │ └── WebConfig.java│ │ │ ├── Dao│ │ │ │ └── Moviedb.java│ │ │ ├── config│ │ │ │ ├── MongoConfig.java│ │ │ │ ├── Mongodb.java│ │ │ │ ├── RootConfig.java│ │ │ │ └── WebAppInitializer.java│ │ │ ├── filter│ │ │ ├── po│ │ │ │ ├── Movie.java│ │ │ │ └── MovieCollection.java│ │ │ └── web│ │ └── mongodbConfig.properties│ └── resources└── test └── java └── Benji └── MongoTest.java //这里仅供参考 src/configWebAppInitializer.java12345678910111213141516171819package Benji.config;import Benji.Controllers.WebConfig;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;//完整的配置类public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings()&#123; //映射到DispatchServlet “/” return new String[]&#123;"/"&#125;; &#125; @Override protected Class&lt;?&gt;[] getRootConfigClasses()&#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses()&#123; return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125;&#125; AbstractAnnotatationConfigDispathcherServletInitializer 容器会在CLASSPATH中查找实现了javax.servlet.ServletContainerInitializer接口的类并用来配置Servlet容器,在Spring中这个由Spring自身实现:SpringServletContainerInitializer类，而这个类又会查找WebApplicationInitializer的类，并且用它来配置Servlet容器，而AbstractAnnotationConfigDispatcherServletInitializer实现了WebApplicationInitializer，所以实现了AbstractAnnotationConfigDispatcherServletInitializer 就能完成配置 AbstractAnnotationConfigDispatcherServletInitializer类需要重写的三个函数 getServletMapping() 分配映射关系 getRootConfigClasses() getServletConfigClasses() 配置DispatcheServlet的相关配置，和XML配置中的Serve letName-servlet.xml中的东西作用相同，如：设计静态资源的管理，视图处理方式 123456789101112131415161718192021222324252627package Benji.Controllers;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration@EnableWebMvc@ComponentScan("Benji.Controllers")public class WebConfig extends WebMvcConfigurerAdapter&#123; @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("WEB-INF/Views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125;&#125;//以上Override的函数的作用，可以参见spring官方文档 如果要配置多个DispatcheServlet,参见stackoverflow 基于Java的配置可以从不同的层次去写，配置类还可以直接继承WebApplicationInitializer等类去配置 编写Controller 传统的Spring-MVCController 123456789101112131415package Benji.Controllers;import static org.springframework.web.bind.annotation.RequestMethod.*;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//import static org.springframework.web.bind.annotation.RequestMethod.GET;@Controller@RequestMapping(value="/")public class HomeHandler &#123; @RequestMapping(method=GET) public String home()&#123; return "index"; &#125;&#125; RESTful的Controller编写 12345678910111213141516171819202122232425262728293031323334package Benji.RESTfulAPI;import Benji.Dao.Moviedb;import Benji.po.Movie;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController //等价于 @Controller + @Responsebodypublic class RestfulController &#123; @Autowired Moviedb moviedb; @GetMapping("/&#123;UserName&#125;") public ResponseEntity&lt;List&lt;Movie&gt;&gt; getByUser(@PathVariable("UserName") String UserName)&#123; List&lt;Movie&gt; movieList = moviedb.findByProvider(UserName); if(movieList.size() == 0)&#123; return new ResponseEntity("provider:"+UserName+"not exit ", HttpStatus.NOT_FOUND ); &#125; /* ResponseEntity会在提供了Converter的条件下将POJO对象转化为对应的数据模式,RESTRful一般采用JSON作为数据格式，故在maven中引入 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt;即可完成自动转化 */ return new ResponseEntity(movieList, HttpStatus.OK); &#125;&#125; 数据库连接 这里用的是Spring-Mongo-data的包 数据库连接配置 1234567891011121314151617181920212223242526272829package Benji.config;import com.mongodb.Mongo;import com.mongodb.MongoClient;import com.mongodb.MongoCredential;import com.mongodb.ServerAddress;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.data.mongodb.config.AbstractMongoConfiguration;import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;import org.springframework.core.env.Environment;import java.net.UnknownHostException;import java.util.Arrays;//import sun.tools.java.Environment;@PropertySource(value = "classpath:mongodbConfig.properties",ignoreResourceNotFound = true)@Configuration@EnableMongoRepositories("Benji.Dao")public class MongoConfig extends AbstractMongoConfiguration &#123; // @Autowired// private Environment env; @Override protected String getDatabaseName() &#123; return "Movie"; &#125; public Mongo mongo() throws Exception &#123; return new MongoClient(new ServerAddress("localhost",21707)); &#125;&#125; Collection连接 1234567891011121314151617181920212223242526272829303132333435package Benji.po;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.util.Collection;import java.util.List;@Document(collection = "Movie")public class MovieCollection &#123; @Id private String id; private String provider; private List&lt;Movie&gt; Movies; public String getId()&#123; return this.id; &#125; public String getProvider()&#123; return this.provider; &#125; public void setId(String id)&#123; this.id=id ; &#125; public void setProvider(String provider)&#123; this.provider = provider; &#125; public List&lt;Movie&gt; getMovies()&#123; return this.Movies; &#125; public void setMovies(List&lt;Movie&gt; Movies)&#123; this.Movies = Movies; &#125;&#125; 定义文档对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Benji.po;import org.springframework.data.annotation.Id;public class Movie &#123; @Id private int Id; private String name; private String size; private String publishtime; private String provider; public void setName(String name)&#123; this.name=name; &#125; public void setSize(String size)&#123; this.size =size; &#125; public void setPublishtime(String PublishedTime)&#123; this.publishtime = PublishedTime; &#125; public void setProvider(String Provider)&#123; this.provider = Provider; &#125; public String getName()&#123; return name; &#125; public String getSize()&#123; return size; &#125; public String getPublishtime()&#123; return publishtime; &#125; public String getProvider()&#123; return provider; &#125; public void setId(int Id)&#123; this.Id = Id; &#125; public Movie(int Id,String name,String size, String publishtime,String provider)&#123; this.name = name; this.Id = Id; this.publishtime = publishtime; this.provider = provider; this.size = size; &#125; public Movie()&#123; &#125; @Override public String toString()&#123; return String.format("Id:%d,Name:%s,Size:%s,Publishtime:%s,Provider:%s",Id,name,size,publishtime,provider); &#125;&#125; 以上就是SpringMvc RESTful服务的基本构成了，再设置一个服务层将CRUD和Controller分开的话，逻辑就会更加清晰些]]></content>
      <categories>
        <category>JavaSpring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CodeLife</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[person_summary.md]]></title>
    <url>%2F2018%2F12%2F24%2Fperson-summary-md%2F</url>
    <content type="text"><![CDATA[web学期总结 1.回（chan)顾(hui)框架和语言and tools Javascript: nodeJs(别的不多说了，贴一张图)和express框架，微信小程序，Vue，mongodb。 Java: Java的基础部分都过了一遍，Spring这套东西还在看。 Python: 平时写算法的时候用，没有进一步的深入学习。Flask框架路由映射的实现，没事写写爬虫(写的都是些玩具。) Go: …算了吧，连官方文档都没有看完。 Docker: Docker image 的构建，Docker微服务的使用 SSH：凑合用吧，能够满足基本需求 Nginx: 基本的反向代理，负载均衡，没有深入学习。 计算机基础 《http权威指南》看到了加密部分。(貌似全忘了。。。) 《计算机网络自顶向下》，看到网络层了的BGP(Border Gateway Protocol)，这一章看的很懵X。 LeetCode算题 《深入理解计算机系统》,看到第二章节了。 《数据库系统设计与原理》，算了，不说了，绪论才看完。 算法：dp算法，分治法。红黑树二叉树(实现代码还没有写完) 碎碎念 我还是单身(立个flag，我要比兔佬提前脱单)，单身挺好的(真香警告.jpg)。 不忘初心，牢记使命，坚定信仰，深入学习习近平新时代中国特色社会主义思想，学习十九大精神，为中国特色社会主义事业奋斗终身，(走错片场了) 竟然胖了三斤，防微杜渐 没钱，穷 大二期间打死都不接前端的锅了 2.想法 这个学期基本上把web开发相关的流程都走了一遍，但是很多都是浅尝辄止，接下来的时间要为暑期实习做准备了 算法方面做的还是不够好，刷题要重视起来。 基础打好 3.规划 寒假把Spring那一套过一遍 把上面三本书都看完一遍，完成实验。 看《算法导论》，刷题(量肯定是要比这个学期多，先定个目标: 15道medium/month，10道hard/month ) 深入学习Docker和Kubernetes 退休。。 找个女朋友]]></content>
      <categories>
        <category>学期总结</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpringMvc]]></title>
    <url>%2F2018%2F12%2F16%2FJavaSpringMvc%2F</url>
    <content type="text"><![CDATA[对最近学习的JavaSpring做一个总结 概念MVC Model View Controller JavaMVCJava的Mvc一般是基于Servlet的Spring Mvc的工作原理 SpringMvc 主要由DispatcherServlet、处理器映射、控制器、视图解析器，视图组成的。 在图中很容易看出，DispatcherServlet 是SpringMvc 是核心，它负责处理Http的请求并根据servletName-servlet.xml提供的信息去寻找处理器。 找到处理器后，调用处理器，DispatcherServlet将请求提交到Controller ，Controller 处理完逻辑代码后返回ModelandView; DispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelandView指定的视图，最后视图负责把结果显示到客户端 一个简单的SpringMvc 部分文件结构(基于maven构建项目,不重要的就不贴了) 123456789101112131415161718192021web文件夹── web ├── WEB-INF │ ├── JSP │ ├── applicationContext.xml │ ├── css │ ├── html │ ├── images │ ├── log4j.properties │ ├── springmvc-servlet.xml │ └── web.xml └── index.jspsrc部分 ├── main │ ├── java │ │ ├── Controller │ │ ├── IndexController.java │ │ ├── LoginController.java │ │ │ │ │ └── resources 先看web.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--以上是一些名字空间命名--&gt; &lt;servlet&gt; &lt;!--这里是servlet实例的配置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--这里是servlet实例的配置文件位置--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。取正整数表示该Servlet容器的加载优先级--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 这是路由请求映射关系，这里指的是所有请求都由sprigmvc这个servlet容器去处理--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springmvc-servlet.xml(这是由命名规则的，servletName-servlet.xml) 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 添加了namespace还需要在schema中声明其位置 --&gt; &lt;context:component-scan base-package="Controller" /&gt; &lt;context:component-scan base-package="service" /&gt; &lt;!--这里采用基于注解的装配控制器方式--&gt; &lt;mvc:annotation-driven /&gt; &lt;!--允许所有css，html images 文件可见--&gt; &lt;!-- resource 过滤掉不需要dispatcherservlet mapping表示匹配原则--&gt; &lt;mvc:resources mapping="/css/**" location="/WEB-INF/css/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/html/**" location="WEB-INF/html/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="WEB-INF/images/"&gt;&lt;/mvc:resources&gt; &lt;!--下面注释的两行是用xml装配控制器的代码--&gt; &lt;!--&lt;bean name="/login" class="LoginController"/&gt;--&gt; &lt;!--&lt;bean name="/register" class="RegisterController"/&gt;--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; &lt;/beans&gt; controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//引入相关的包，这里包括了注释部分需要的包@Controller//分层路由处理public class IndexController &#123; @RequestMapping("/login") //@RequestMapping("/login")完成了对/login的映射，当请求为/login时交由login函数处理 public String login()&#123; return "login"; /* 这里返回 login ，由于在xml中有声明 &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; 所以实际视图解析器会去/html目录下去查找login.html文件 */ &#125; @RequestMapping("/register") public String register(HttpServletRequest request, HttpServletResponse response)&#123; // 行为参数获取请求参数 String uname = request.getParameter("uname"); String upass= request.getParameter("upass"); //code to verify //... //if not verified return "register"; //if verified //return "login";&#125; //通过@PathVariable 获取参数// @RequestMapping(value = "/register/&#123;uname&#125;/&#123;upass&#125;/",method = RequestMethod.GET)// public String register(@PathVariable String uname, @PathVariable String upass,Model model)&#123;// //code to verify// //model for jsp// return "register";// &#125; //通过@PathParam接受请求参数// @RequestMapping("/register")// public String register(@RequestParam String uname,@RequestParam String upass)&#123;// //code to verify// return "login";// &#125;// @RequestParam 和通过形式参数获取请求参数时，使用前者方式，请求参数和接收参数不一致时会返回404，而后者不会 //重定向 return "forward:/index/isLogin";// return "redirect:/index/isRegister";&#125; 小结 最近在看JavaSpring的东西，感觉Java好重，这篇就是自己回顾，感觉写的乱七八糟，关于JavaSpring的推荐去看《JavaSpring实战》 还是脚本语言写应用层后端爽，感觉Java的优势主要体现在大的项目]]></content>
      <categories>
        <category>JavaSpring</category>
      </categories>
      <tags>
        <tag>SpringMvc</tag>
        <tag>Backend</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门总结]]></title>
    <url>%2F2018%2F12%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[这是我个人学习使用Docker的知识总结，如果想要系统的学习参照官方文档 简单理解 docker是一种容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。先来一张图 docker相对于虚拟机来说要便捷许多。 docker与虚拟机的比较 特性 docker 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB级 GB级别 性能 接近原生 若弱于原生 系统容纳量 单机支持上千个容器 一般十几个 docker的结构 用一张图来表示吧 简单地说，docker存在image，container这两种东西，要跑的是container。而container是由image产生的，而image可以通过docker build 出来，也可以从远程repository pull下来。 Docker build 首先，先要建立一个Dockerfile。Dockerfile里面写的代码可以理解为创建image的一个流程，当然实际生成一个image后面有很多看不到的过程, (以搭建一个nodejs后端服务器为例): 123456789101112FROM node: version# 首先指定镜像基础，这里是构建node环境并指定版本COPY . /app # 指定工作目录WORKDIR /app# 将当前目录拷贝到images的/app目录RUN npm install --repository=https://registry.npm.taobao.org# 安装nodeJS程序的依赖EXPOSE 8008# 开放image的3000端口CMD ["node", "server.js"]# 在container运行时执行 node server.js 创建dockerfile之后，再新建.dockerignore 文件，这里主要是排除一些不要被build的文件 1234.git node_modulesnpm-debug.log# 这里主要是排除git，和nodejs的模块，需要的模块在在build的时候 RUN npm install 会自动安装 build 1docker build -t imageName path path为build的文件目录”起点“，一般是”./“ 即当前目录 Docker Run 首先我们要跑的是container，所以可以先查看有哪些container 1docker container ls Run 12345docker container run --rm -p 8080:8008 -i -t imageName /bin/bash //--rm 表示container停止后自动删除容器文件//-i 让容器的标注输入保持打开//-t 让Docker 分配一个伪终端并绑定到容器的标准输入上//-p 表示端口映射，将docker的8008端口映射到宿主机的8080端口 Docker 命令的一些细节 退出docker 1234561. docker kill containerID //结束进程，containerId的话不需要输全的，只要前四位就行啦2. dockerstop containerName//在docker 里面1. Ctrl+D 2. exit 进入Docker 12341. docker attch [option] containerId//忘记怎么使用的可以docker attch --help 2. docker exec [options] //如:进入redis, $ docker exec containerId redis-cli Docker 的一些推荐 阮一峰Docker入门教程 阮一峰Docker微服务 Docker–从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Docker</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 1234567891011121314// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值//如果该模型存在的话，就会放货这个模型 以上是我认为一个后端程序的基本结构了。有些东西一直在变化，如有问题请参照官方文档。 启动 基本的：node server.js 要知道，后端不仅仅是将程序跑起来，运维也是一个很大的问题。这里推荐使用pm2 当然，现在微服务很流行，docker也是很必要的啦！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Spring Jdbc学习笔记]]></title>
    <url>%2F2018%2F12%2F02%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[JavaSpring事务管理(1) 文件结构1234567.├── applicationContext.xml└── scheme ├── Dao.java ├── JdbcTest.java ├── TestDaoImpl.java ├── User.java JDBC配置省略部分代码applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;context:component-scan base-package="JDBC.scheme"&gt;&lt;/context:component-scan&gt;&lt;!-- 申明该xml配置文件“作用范围” --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/java?useSSL=false"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value=""&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置需要连接数据库信息 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建JdbcTemplate模版--&gt;&lt;/beans&gt;``` ## 创建实体类 User.java```javapublic class User &#123; //映射的事情由jdbctemplate来完成，前提是名字与数据库里面的要一一对应； private Integer id; private String name; private String sex; //toString方便查看对象属性 public String toString()&#123; return "myuser(id="+String.valueOf(id)+",name:"+name+",sex:"+sex+"date:"+"2018]"; &#125; public void setId(Integer id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setSex(String sex)&#123; this.sex = sex; &#125;&#125; JavaTemplate实例的创建TestDaoImpl.java1234567891011121314151617181920212223242526272829303132333435@Repository("testDao")//将该实例注入xml文件，交由Spring来管理，可用ApplicationContext对象的getBean("testDao")获取public class TestDaoImpl implements Dao &#123; @Autowired //使用xml文件中配置好的jdbc实例 private JdbcTemplate jdbcTemplate; @Override //对Dao的接口重写 public int update(String sql,Object[] param)&#123; return jdbcTemplate.update(sql,param); //返回更新的行数 &#125; @Override public List&lt;User&gt; query(String sql, Object[] param)&#123; //这里使用BeanPropertyRowMapper会比自己实现RowMapper要简单一些 // BeanPropertyRowMapper可以自动调用相应的setter对对象进行赋值 RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); return jdbcTemplate.query(sql,rowMapper,param); // RowMapper&lt;User&gt; userMapper = new UserMapper(); // return jdbcTemplate.query(sql,userMapper,param); &#125;&#125;//如果要用注释所用方法query,则需要自己实现一个RowMapper类class UserMapper implements RowMapper&lt;User&gt; &#123; //结果是以 行 为单位返回的 public User mapRow(ResultSet rs,int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); user.setSex(rs.getString("sex")); return user; &#125;&#125; 测试JdbcTest.java1234567891011121314151617181920212223public class JdbcTest &#123; public static void main(String[] args)&#123; ApplicationContext appcon = new ClassPathXmlApplicationContext("/JDBC/applicationContext.xml");// ApplicationContext appcom = new FileSystemXmlApplicationContext("src/JDBC/applicationContext.xml"); Dao td = (Dao) appcon.getBean("testDao"); String insertSql = "insert into user values(?,?,?,NOW())"; Object param1[]=&#123;1,"Benji","boy"&#125;; Object param2[]=&#123;2,"Lee","boy"&#125;; Object param3[]=&#123;3,"Jimmy","boy"&#125;; Object param4[]=&#123;4,"Lily","girl"&#125;; Object param5[]=&#123;5,"Morry","girl"&#125;; td.update(insertSql,param1); td.update(insertSql,param2); td.update(insertSql,param3); td.update(insertSql,param4); td.update(insertSql,param5); String selectSql = "select * from user"; List&lt;User&gt; list = td.query(selectSql,null); for(User user:list)&#123; System.out.println(user); &#125; &#125;&#125; JdbcTemplate 常用方法 update() query() …和SQL语句差不多,可以查询官方文档]]></content>
      <categories>
        <category>JavaSpring学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CodeLife</tag>
        <tag>Backend</tag>
        <tag>Curd</tag>
      </tags>
  </entry>
</search>
