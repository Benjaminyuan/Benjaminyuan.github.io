<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F05%2F11%2Ftricks%2F</url>
    <content type="text"><![CDATA[记录一些编程小技巧JavaList to Array 使用 (Type[] )list.toArray(); 可能会造成CastException，可以用 list.toArray(new Type[0]);]]></content>
  </entry>
  <entry>
    <title><![CDATA[design_patterns]]></title>
    <url>%2F2020%2F02%2F09%2Fdesign-patterns%2F</url>
    <content type="text"><![CDATA[设计模式笔记 设计模式类型创建型模式工厂模式 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象 意图：定义一个创建对象的接口，让其子类决定自己实例话哪一个工厂类，工厂模式使其创建过程延迟到子类进行 实现12345public interface Shape&#123; void draw()&#125;class 结构型模式行为型模式设计模式原则开闭原则 对拓展开放，对修改关闭里氏替换原则 任何基类可以出现的地方，子类一定可以出现依赖倒转原则 开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体接口隔离原则 使用多个隔离的接口，比使用单个要好 降低类之间的耦合度最少知道原则合成复用原则 领域模型失血模式 失血模型中，domain object 只有属性的get,set方法的纯数据类，所有业务逻辑都由Service层来完成的，由于没有dao,Service直接操作数据库，进行数据持久化。 单纯的POJO 贫血模型 贫血模型中，domain object包含了不依赖于持久化的原子领域逻辑，而组合逻辑在service层。 service：组合服务 Model:get/set方法，还包含原子服务 dao：数据持久化 简单地说就是只有状态 充血模型 充血模型中，绝大多数业务逻辑都应该domain Object 里面，包括持久化逻辑，而Service层是很薄的一层，仅仅封装事物和少量逻辑，不和Dao层打交道 service：组合服务 model： 除get/set方法，还包含原子服务 状态和行为。 肿血模型 该模型取消了Service层，只剩下domain object 和Dao 层，在domain object的domain logic上面封装事物。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux Kernel]]></title>
    <url>%2F2020%2F02%2F09%2FLinux-kernel%2F</url>
    <content type="text"><![CDATA[《Linux内核设计与实现》笔记 内核简介内核组成? 负责响应中断的中断服务程序 负责管理多个进程，分享处理器时间的调用程序 复制进程地址空间的内存管理程序 网络、进程间通讯等系统服务程序Linux内核和Unix内核的比较 所有Unix内核同宗同源，提供的API是一样的 Unix内核需要硬件提供MMU管理内存， Linux一般不需要微内核和单内核设计比较 单内核所有的服务都在同一地址空间，内核可以直接调用函数，微内核的功能被划分为多个独立的过程，每个过程被叫做服务器，所有的服务器都运行在各自的地址空间上，服务器之间的通讯需要通过消息传递（IPC）。 IPC的开销大于函数调用Linux的优点 Linux是单内核，但是Linux吸取了微内核的精华，支持模块化设计、抢占式内核、支持内核线程、动态装载内核模块 Linux和Unix的差异 Linux支持动态加载内核模块，单内核，但是可以在允许时动态的卸载和加载除部分内核代码 Linux支持对称多处理器（SMP），传统Unix并不支持 Linux内核可以抢占，Linux内核具有允许在内核运行的任务优先执行的能力， Linux内核不区分线程和其他一般的进程。对于内核来说，所有进程都一样，只不过一些共享的资源不同Linux内核版本12345// 主版本号 修订版本号// ｜ |// 2 . 6 . 26 . 1// | ｜// 从版本号 稳定版本号 进程管理进程 线程：拥有独立的程序计数器，进程栈，一组进程寄存器 内核调度对象是线程 进程是处于执行期的程序以及相关的资源的总称 线程：fork()-&gt;clone()进程描述符及任务结构 进程描述符：task_struct 任务队列：task_struct的双向链表 分配进程描述符 Linux通过slab分配器分配，2.6以前，各个进程的task_struct存放在他们内核栈的尾端，（方便查找），2.6之后，slab分配器动态生成task_struck，所以只需要在栈低(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)/创建一个struct thread_info 进程描述符存放 pid:唯一标识进程（int），最大值为32768（short int 短整数的最大值） current宏查找当前正在运行的进程。 x86 体系：利用计算偏移间接地查找task_struct结构（抹去低13位） 专门的寄存器存储thread_info地址进程状态 TASK_RUNNING：运行或者在任务队列中等待执行 TASK_INTERRUPTIBLE：进程正在睡眠，等待某些条件达成，或者收到信号被唤醒 TASK_UNINTERRUPTIBLE：不可以被信号唤醒 _TASK_TRACED：被其他进程追踪。 _TASK_STOPPED：进程停止执行：没有投入运行也不能投入运行设置当前进程状态 set_task_state(task,state)进程上下文 程序执行了系统调用，或触发了某个异常，它就陷入了内核空间，内核代表进程执行处于“进程上下文”中，在此上下文中current宏是有效的进程家族树 所有的进程都是PID为1的进程的后代进程创建 fork()调用：拷贝当前进程创建一个子进程。子进程和父进程的区别仅仅在于PID，PPID(父进程的PID)和某些资源和统计量（挂起的信号，没有必要别继承）写时拷贝 fork()使用copy-on-write页实现，fork()的开销主要在于复制父进程的页表以及给子进程创建唯一的PIDfork() 调用链 1\\ fork() -&gt; clone() -&gt; do_fork() -&gt; copy_process() -&gt; dup_task_struct() copy_proces() 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct（此时与当前线程无任何差别） 确保创建子进程后，分配给用户的资源没有超过限制 子进程状态设置为TASK_UNITERRUPTIBLE，保证不会投入运行 copy_flags()更新task_struct的flags成员，确保一些flag被设置或清零（代表是否拥有超级用户权限的PF_SUPERPRIV清零，表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置） 调用alloc_pid()为新进程分配一个有效的PID 根据传递给clone的参数标志不同，copy_process拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。共享的话不拷贝，不共享则拷贝。 返回一个指向子进程的指针。 回到do_fork() copy_process调用成功后，新创建的子进程被唤醒并让其投入运行vfork() 除了不拷贝父进程的页表项外，vfork()和fork()功能一致线程在Linux的实现 线程：进程间的共享资源的手段。创建线程12clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,0);//共享地址空间、文件系统资源、文件描述符、信号处理程序 内核线程 内核线程和普通线程的区别：内核线程没有独立的地址空间（指向地址空间的mm指针被设置为NULL）,内核线程只在内核空间运行，从来不到用户空间去。进程终结 终结（可以显示调用exit()）动作：释放资源，传递信号给父进程 主要工作由do_exit()完成 将task_struct中的标志成员设置为PF_EXITING 调用del_timer_sync()删除任意内核定时器，确保没有定时器在排队 BSD的进程记账功能是开启的话，调用acct_update_integrals()来输出记栈信息 exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用他们，就彻底释放它们。 sem__exit()如果进程排队等候IPC信号，它则离队 exit_files()和exit_fs()递减文件描述符，文件系统数据的引用计数，如果某个引用计数数值降为0，此时可以释放 存放task_struct的exit_code成员中的任务退出代码置为exit()提供的退出代码，方便父进程随时检索 exit_notify()向父进程发送信号，给子进程重新找养父，并把线程状态设置为EXIT_ZOMBIE 调用schedule()切换到新的进程。 处于EXIT_ZOMBIE状态的进程占用内存为内核栈，thread_info结构和stak_struct结构，唯一作用是给父进程提供信息。在父进程获取已终结的子进程信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放， wait()：挂起一个进程，直到其中的一个进程退出。（会释放内核栈和thread_info的结构所占的页，并释放task_struct所占的slab高速缓存进程调度 多任务 现代操作系统对程序一般采用动态时间片计算的方式，并且引入了可配置的计算策略。（但是Linux不是）Linux的进程调度 Linux2.5：采用O(1)调度程序 Linux2.6初期：引入新的调度算法，其中最著名的是：“反转楼梯最后期限调度算法”(RSDL) Linux2.6.23内核版本中替代了O(1)调度算法，取而代之的是（完全公平调度算法）CFS 策略I/O消耗型和处理器消耗型的进程 I/O消耗型：大多时间在等待I/O请求或者提交I/O请求。 处理器消耗型：进程时间大多数用在执行代码上。进程优先级 Linux采用两种不同的优先级 nice值 range: -20到+19 nice越低优先级越高 nice是所有Unix系统中的标准化的概念，但是由于调度算法不同，运用方式不同 Mac OS X，进程的nice值代表分配给进程的时间片的绝对值，而Linux系统，nice值则代表时间片的比例。 实时优先级 默认值：0到99，越高线程优先级越高时间片 表明线程在被抢占前能够持续运行的时间。调度策略必须规定一个时间片 Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了线程，这样使得线程获得的处理器时间其实是和系统负载密切相关的。nice值作为权重调整进程所使用的处理器时间使用比。 Linux的抢占行为：当一个进程进入可运行状态时，抢占时机取决于新的可运行程序消耗多少处理器使用比。如果消耗的使用比 比当前进程小，则新进程立刻投入运行，否则推迟运行。Linux调度算法 调度器类 Linux调度器使用模块的方式提供，使得不同类型的进程可以有针对性地选择调度算法。 Unix系统中的进程调度 两点：进程优先级、时间片 问题：分配绝对的时间片会引发固定的切换频率 完全公平调度(CFS)是一个针对普通进程的调度类，Linux中称为 SCHED_NORMAL CFS完全摈弃时间片而是分配给进程一个处理器使用比重 CFS理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器 周转：允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。 CFS在所有可运行的进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重，越高的nice值获得越低的处理器使用权重。CFS进程获得的时间片底线默认值为1ms（防止频繁切换） 任何线程所获得的处理器时间是他自己和其他所有可运行进程nice值的相对差值决定的Linux调度的实现时间记账 CFS使用调度器实体结构：struct sched_entity来追踪进程运行记账，struct task_struct中名为se的成员变量 虚拟实时：vruntime，进程的虚拟运行时间（进过所有可运行进程总数的标准化） 系统定时器周期性调用update_curr计算进程上次计算到当前计算的delta_exec，通过进程总数对运行时间进程加权运算，最后将权重值与运行进程的vruntime相加进程选择 核心：当要选择下一个进程时，它会挑一个具有最小vruntime的进程。 CFS通过红黑树来组织可运行的进程队列：CFS选择算法可以总结为运行rbtree中的最左边的叶子节点所代表的那个进程 删除进程发生在 进程阻塞（不可运行态）或者终止时（结束运行）调度器入口 schedule()：通常都需要和一个具体的调度类相关联（高优先级优先），调用pick_next_task()选择进程睡眠和唤醒 等待队列：等待某些时间发生的的进程简单链表，内核用wake_queue_head_t来代表等待队列 创建：DECLARE_WAITQUEUE()静态创建或init_waitqueue_head()动态创建 加入等待队列 123456789DEFINE_WAIT(wait);add_wait_queue(q,&amp;wait);while(!condition)&#123; prepare_to_wait(&amp;q,&amp;wait,TASK_INTERRUPTIBLE); if(signal_pending(current)) //处理信号 schedule();&#125;finish_wait(&amp;q,&amp;wait); 调用DECLARE_WAITQUEUE()创建一个等待队列 add_wait_queue()把自己加入队列中，该队列会在进程等待的条件满足是唤醒，时间发生时，对等待队列执行wake_up()操作 prepare_to_wait()将进程状态变为TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE 如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程（伪唤醒） 进程被唤醒的时候，它会再次检查条件是否为真，如果是则退出循环，否则再次调用schedule()并一直重复这步操作 当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己退出等待队列 唤醒 wake_up()进行，唤醒指定的等待队列上的所有进程。 调用函数try_to_wake_up()将进程设置为TASK_RUNNING状态 调用enqueue_task()将进程放入红黑树中。 如果被唤醒的进程优先级比当前正在执行的进程优先级高，还要设置need_resched标志。通常哪段代码促使等待条件达成，就要负责随后调用wake_up()函数。抢占和上下文切换 上下文切换：可执行进程切换到另外一个可执行线程。当一个进程被选出来准备投入运行时，schedule() 会调用context_switch() switch_mm()负责把虚拟内存从上一个进程映射切换到新进程中 switch_to()该函数负责从上一个进程的处理器状态切换到新进程的处理器状态（保存、恢复栈信息和寄存器信息）。 内核提供一个need_resched标志（每一个进程都包括一个标志）来表明是否需要重新执行一次调度。 当进程被抢占时，scheduler_tick()就会设置这个标志 当优先级高的进程进入可执行状态的时候，try_to_wake_up()也会设置这个标志 返回用户空间以及从中断返回的时候，内核也会检查need_resched标志，如果被设置，内核会在继续执行之前调用调度程序 用户抢占 用户抢占发生 系统返回用户空间时 从中断处理程序返回用户空间时内核抢占 只要调度是安全的，内核可以在任何时间抢占正在执行的任务 支持 为每一个进程的thread_info引入preempt_count计数器，初值为0，每当使用锁的时候数值加1，释放锁的时候数值减1，数值为0时可以抢占。 need_resched被设置，同时preempt_count为0时，调度程序就会被调用 发生时机 中断处理程序正在执行，且返回内核空间之前 内核代码再一次具有可抢占性的时候 如果内核中的任务显示调用schedule() 如果内核中的任务阻塞（同样调用schedule())实时调度策略 两种调度策略：SCHED_FIFO和SCHED_RR SCHED_FIFO 处于可以运行状态的SCHED_FIFO级进程会比任何SCHED_NORMAL级的进程都先得到调度 一旦SCHED_FIFO级进程处于可执行状态，就会一直执行（可以被高优先级抢占），同级的SCHED_FIFO进程轮流执行，直到自己受阻塞或者显式地释放处理器为止 SCHED_RR SCHED_RR与SCHED_FIFO大致相同 SCHED_RR是带时间片的SCHED_FIFO,时间片用于调度同一优先级处理器绑定 Linux提供强制的处理器绑定机制。 保存在task_strcut 的cpus_allowed位掩码，默认所有位被设置放弃处理器时间 Linux通过sched_yield()系统调用，让进程显示地将处理其时间让给其他等待执行进程系统调用内核通讯 Linux中系统调用是用户空间访问内核的唯一手段POSIX、API、C库调用关系 应用程序–&gt; C库–&gt; 内核 Unix接口设计：“提供机制而不是策略”,机制：“需要提供什么样的功能”，策略：“怎样实现这些功能”系统调用 通常通过C库中定义的函数调用来进行 系统调用出错的时候C库会把错误码写入errno全局变量，调用perror()库函数，可以把变量翻译成用户可以理解的错误字符串 getpid()系统调用 123SYSCALL_DEFINE0(getpid)&#123; return task_tgid_vnr(current);//return current-&gt;tgid&#125; SYSCALL_DEFINE0 只是一个宏，定义一个无参数的系统调用 SYSCALL_DEFINE(functionName,param_1_type,param_1,type return_param) 定义 asmlinkage：编译指令，通知编译器仅从栈中提取该函数的参数 1asmlinkage long sys_getpid(void) 命名：sys_functionName() 系统调用号 Linux中，每个系统调用被赋予一个系统调用号，一旦分配就不能再有任何变更 如果一个系统调用被删除，防止编译的代码出错 Linux有一个“未实现”系统调用sys_in_syscall()，它除了返回-ENOSYS不做任何事情，为错误的系统调用而设的。 系统调用表：sys_call_table（x86-64中，它定义于arch/i386/kernel/syscall_64.c系统调用性能 Linux系统调用比许多操作系统执行要快（很多，指谁？），上下文切换时间较短，系统调用处理程序和每个系统调用本身就很简洁系统调用处理程序 用户空间的程序无法直接执行内核代码，因此应用程序需要用某种方式通知系统，告诉内核自己需要执行一个系统调用。 策略：系统切换到内核态，代表应用程序在内核空间执行系统调用 通知内核机制：软中断 通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序实际上是系统调用处理程序。 在X86系统上预定义的软中断是中断号128,通过int $0x80指令触发该中断，该指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序–system_call()指定恰当的系统调用 陷入内核的同时需要将系统调用号传给内核 X86上，系统调用号是通过eax寄存器传递给内核的 system_call()函数 通过传递给定的系统调用号与NR_syscalls做比较来检查有效性,如果大于等于 NR_syscalls，该函数返回-ENOSYS，否则执行响应的系统调用1call *sys_call_table(,%rax,8) 参数传递 最简单的方式：将参数传入寄存器中，x86-32系统上，ebx、ecx、edx、esi和edi按照顺序存放前5个参数，需要6个或者六个以上使，用一个单独的寄存器存放指向指向这些参数的用户地址系统调用实现实现系统调用 要点：“提供机制而不是策略”参数验证 检查传入参数合法性 I/O调用：文件描述符是否有效 进程相关：进程PID是否有效 资源访问： 用户指针指向的内存属于用户空间 指针指向的内存区域在进程的地址空间里 进程不能绕过内存访问限制 定义系统调用实例1234567891011SYSCALL_DEFINE3(silly_copy,unsigned long *,src,unsigned long * dst,unsigned long len)&#123; unsigned long buf; //copy_from_user都是返回没有完成拷贝的字节 if(copy_from_user(&amp;buf,src,len))&#123; return -EFAULT; &#125; if(copy_to_user(dst,&amp;buf,len))&#123; return -EFAULT; &#125; return len;&#125; 系统调用上下文 系统在执行系统调用时处于进程上下文 current执行当前任务，即引发系统调用的那个进程绑定系统调用 Linux系统调用表 首先在系统调用表中加入一个表项，从0开始 对于所支持的各种体系结构，系统调用号都必须定义于\&lt;asm\/unistd.h>中 系统调用必须被编译成内核映像（放在kernel/下的一个相关文件中就行来了） 定义一个名为foo()的系统调用为例 加入系统调用表（entry.s)(Linux5.4中x86系统调用表位置：arch/x86/entry/syscalls/syscall_64.tbl) 添加系统调用号(Linux5.4中x86系统调用号定义位置：arch/sh/include/uapi/asm/unistd_64.h） 编写系统调用 用DEFINE\&lt;n>的宏定义（最后展开是一样的）123asmlinkage returnType funcName(type params)&#123; // code &#125; 从用户空间访问系统调用 库 系统调用宏形式,_syscalln()1#define NR_open 5 _syscall3(long,open,const char*,filename,int,flags,int,mode) 内核数据结构链表 Linux链表不是将数据结构塞入链表，而是将链表节点塞入数据结构 12345//链表结构struct list_head&#123; struct list_head *next; struct list_head *prev;&#125; 通过宏container_of()我们可以很方便地从链表指针找到父结构中包含的任何变量 123456struct fox &#123; unsigned long tail_length; unsigned long weight; bool is_fantastic; struct list_head list;&#125; Linux提供一系列操作链表API 队列映射二叉树]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM笔记]]></title>
    <url>%2F2020%2F02%2F08%2Fjvm%2F</url>
    <content type="text"><![CDATA[JVM 整体思路 公有设计，私有实现，始终贯穿，不同虚拟机对于jvm的设计实现上有一定的差别 Java内存区域和内存移除异常 把图都画一起了（运行时数据区域程序计数器 程序位置指示器 线程私有Java虚拟机栈 线程私有 方法执行时会创建栈帧 局部变量表:用变量槽（32位）保存8种基本数据类型&amp;&amp; 引用， 操作数栈（Java指令架构时基于栈的） 动态连接 方法出口本地方法栈 和虚拟机栈类似 区别在于是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务堆 对象实例存放的地方 可以通过-Xms,-Xmx改变大小 方法区 存放虚拟机加载的类型信息，常量，静态变量，即时编译后(JIT)的代码缓存 包括运行时常量池 编译期生成的各种字面量和符号引用，类加载后会存放进方法区 Hotpot 采用本地内存来实现元空间，元空间是方法区的实现 直接内存 不属于虚拟机运行时数据区 I/O时分配堆外内存，可以减少一次Java堆到Native堆的拷贝 减少垃圾回收的压力 难以控制，容易造成内存泄漏HotPot虚拟机对象 对象创建 new字节码指令执行过程 常量池中定位符号引用 检查符号引用对于的类是否加载，如果没有加载，这先执行类加载 分配内存（取决于垃圾收集器是否带有空间压缩整理的能力） 内存绝对规整：指针碰撞（Bump The Pointer） 不规整（已使用内存和未使用内存交错）：维护一个空闲列表 更新的原子性 CAS + 失败重试 每个线程预分配(Thread Local Allocation Buffer TLAB) 设置对象初始信息 对象头（Object Header） 执行构造函数()对象内存布局 mark word 123456// 32bit //-----//hash:25:-----------------&gt;| age:4 biased_lock:1 lock:2 (normal object)//JavaThread*: epoch:2 age:4 Biased_lock:1 lock:2 (biased object)//size:32--------------------------------------&gt;| (CMS free block)//PromotedObject*:29--------&gt;| promo_bits:3----&gt;| (CMS promoted object) 对象有效信息: 从自身定义字段+父类继承下来的字段 HotSpot分配策略 存储顺序：longs/doubles,floats,ints,shorts,chars,bytes/booleans,oops 相同宽度的字段总是被分配在一起 在满足以上前提，父类定义的字段会出现在子类之前 对其填充 HotSpot虚拟机自动内存管理要求对象起始地址必须是8字节的整数倍对象的访问定位 主流访问方式 使用句柄：对象移动时，只改变句柄池的实例数据指针 直接指针：直接指向对象的内存位置 区别：使用句柄多一次指针定位的时间开销 HotSpot使用直接指针OutOfMemoryError异常Java堆溢出虚拟机栈和本地方法栈溢出 请求栈深度大于虚拟机允许的深度 –&gt; StackOverflow，常见：递归 当虚拟机栈内存允许动态拓展，拓展栈无法申请到足够的内存时，将抛出OutOfMemoryError异常（HotSpot不支持） 方法区和运行时常量池溢出 字符串问题 String.intern()方法，JDK6中，首次遇到的字符串实例复制到永久代的字符串常量池中，返回的也是永久代里面这个字符串的引用，而JDK7 只需要将常量池里面记录一下首次出现的实例引用即可 JDK6 HotSpot中，字符串常量池在方法区（永久代），而JDK7 后，被移到类Java堆中 方法区溢出 CGLib技术直接操作字节码运行时生成大量的动态类本机直接内存溢出 Unsafe类向操作系统申请内存 问题排查：是否使用了DirectMemory 垃圾收集器和内存分配策略聚焦问题 那些内存需要回收 什么时候回收 如何回收 对象存活问题引用计数算法 描述：在对象中添加一个引用计数器，每有一个地方引用它，计数器值就加1，引用失效时就减1，应用为0则无用了 简单，效率高，但是存在循环引用问题可达性分析算法 描述：通过一系列的“GC Root” 的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，如果对象不跟任何引用链相连，则被认为不再被使用。 Java技术体系里面，固定可以作为GC Roots的对象包括 虚拟机栈中引用的对象， 方法区中的静态属性引用，如类的引用类型静态变量 方法区中常量引用的对象，譬如字符串常量池里引用的对象 本地方法栈中的JNI引用的对象 Java虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻的异常等，还有系统的类加载器 所有被同步锁持有的对象 Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等 除以上固定的，还有其他对象“临时性”地加入，共同构成完整的GCRoots集合引用引用 应用的概念扩冲 强引用：Object obj = new Object(); 软引用：有用非必须，在将要发生内存溢出异常前，会把这些对象列进回收范围进行第二次回收，如果这次回收没有足够的内存，才会发生内存异常，JDK 1.2版本之后提供列SoftReference类来实现软引用 弱引用：非必须对象，关联的对象只能生存到下一次垃圾收集发生为止。JDK 1.2后使用WeakReference类来实现弱引用 虚引用：不会对对象的生存时间构成影响 JDK 1.2后，提供PhantomReference类来实现虚引用To die to 死亡 –&gt; finalize() F-Queue队列由虚拟机自动建立的，低调度优先级的Finalizer线程去执行finalize()方法（不保证能够执行完成） 一个对象的finalize()只能执行一次回收方法区 允许回收条件 该类的所有实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例 该类的类加载器被回收，一般很难达成 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射获得该类的方法 允许回收不一定要回收垃圾回收算法分代收集理论 假说 弱分代假说：绝大多数对象都是朝生夕灭 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 跨代引用假说：跨代引用相对与同代引用来说仅占及其少数 –&gt; 引出记忆集概念标记-清除算法 描述：标记所有要清除的算法，标记完成后统一回收所有被标记的对象 缺点： 执行效率不高，需要扫描大量对象，执行大量标记和清除动作。 内存空间的碎片化问题，标记、清除之后产生的大量不连续的内存碎片。标记-复制算法 描述：将可用内存分为大小相等的两块，每次只使用其中的一块。每一块用完了就将还存活的对象赋值到另外一块（HotSpot是8:1:1） 商用Java虚拟机大多采用这种算法收集新生代。 标记-整理 描述：存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。 缺点： 移动存活对象需要STW 移动和不移动，that’s a question: 不移动影响内存分配，移动影响吞吐量 HotSpot算法细节实现根节点枚举 根节点枚举必须在一个保障一致性的快照中进行（所有的收集器在根节点枚举时都得STW） 改进： 准确式垃圾收集：用户线程停下来后，不需要逐个检查引用位置，虚拟机存储存放对象引用的地方 HotSpot解决方案：使用一组OopMap的数据结构，类加载动作完成时，记录对象内制定偏移位置的数据类型。无需一个不漏地从方法区等GC Roots开始查找 安全点 OopMap的问题：让OopMap内容变化的指令很多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间。HotSpot只在特定的地方记录OopMap，这些位置被称为 安全点 所有线程跑到最近的安全点才能暂停，开始垃圾收集 安全点位置选取：以“是否具有让程序长时间执行的特征” 为标准进行选定的，如方法调用，循环跳转，异常跳转等功能指令才会产生安全点 中断有两种方式 抢先式中断：垃圾回收时，系统首先把所有的用户线程全部中断，如果有线程没有中断在安全点上，则恢复执行，直到跑到安全点上。 主动式中断：当垃圾回收需要中断线程时，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程中会不停地主动轮询这个标志，一旦发现中断标志为真就自己在最近的安全点上主动中断挂起。安全区域 定义：一段代码片段之中，引用关系不会发生变化，因此在这个区域任何地方开始垃圾回收都是安全的。 行为：当线程会标识进入安全区域，当这段时间发生垃圾回收时，虚拟机不会管已声明在安全区域的线程，当线程离开安全区时，需要检查虚拟机是否已经完成了跟节点枚举，只有完成跟节点枚举才能继续运行记忆集与卡集 定义：记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构 记忆集精度 字长精度 对象精度 卡精度：“卡表” 卡表的简单形式可以是一个字节数组，HotSpot实现也是这样 123//HotSpot使用的卡页大小为2的9次幂，512字节//只要卡页里面有跨代指针就标识为1，称为变脏，将其加入GC Roots中一并扫描CARD_TABLE[this_address &gt;&gt; 9] =0; 写屏障（区分“内存屏障”） 虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，类似与AOP技术，在赋值前的操作叫做写前屏障，在赋值后的操作叫做写后屏障。 HotSpot 通过写屏障技术维护卡表状态，在写屏障中添加更新卡表操作。 卡表更新的缓存问题：改成只有没有变脏的才能变脏，HotSpot：-XX:+UseCondCardMark,开启 并发的可达性分析 引出问题：GCRoots相比Java堆的对象是极少数的，停顿时间较短，但是遍历对象图时间和Java堆容量成正比，需要削减遍历时间 三色标记法 白色：对象未被垃圾收集器访问过。开始时-&gt;都为白色，结束时白色-&gt;不可达 黑色：标示被垃圾收集器访问过，且其所有的引用都已经扫描过了 灰色：被访问过，但是对象上至少还有一个引用没有被扫描过 并发工作是可能存在的问题： 赋值器插入了一条或多条黑色对象到白色对象的新引用 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用 解决方案 增量更新：记录被新插入指向白色对象引用的黑色对象，并发扫描结束后以这些记录过的黑色对象为根，重新扫描一次。(CMS) 原始快照：当灰色对象要删除指向白色对象的引用时，记录要被删除的引用记录，在扫描结束之后，与这些记录过的引用关系中的灰色对象为根重新扫描一次。(G1,Shenandoah) 相比增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗。分配担保机制 在minor GC之前，虚拟机必须检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，则MinorGC是安全的，如果不成立，虚拟机会先查看-XX:HandlePromotionFailure是否运行担保失败，如果允许那就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，可以进行minor GC,否则进行一次Full GC 经典垃圾回收器Serial收集器 描述：单线程工作的收集器，一个线程处理垃圾收集工作，同时必须暂停其他工作线程。 新生代：标记-复制，老年代：标志-整理 。 HotSpot虚拟机客户端模式下默认新生代收集器 优点：内存消耗最小，单核处理器或处理器核心数较少的环境来说，serial收集器没有线程交互的开销。在系统分配资源较少时，还不错。ParNew收集器 描述：ParNew收集器实质上是Serial收集器的多线程并行版本 新生代：标记-复制 大多数运行在服务端模式下的HotSpot虚拟机中首选的新生代收集器 默认开启收集线程数和处理器逻辑核心数量相同 Parallel Scavenge收集器 描述：基于标记-复制算法实现的新生代收集器，关注点是达到一个可控制的吞吐量。 $$吞吐量 = {运行用户代码时间}/{(运行用户代码时间+运行垃圾收集时间)}$$ 策略：控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis，设置吞吐量大小-XX:GCTimeRatio,垃圾停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。 Serial Old收集器 描述：单线程Serial收集器的老年代版本，使用标记-清除 用途： Parallel Scavenge收集器搭配使用 作为CMS收集器发生Concurrent Mode Failure 时的后备预案Parallel Old收集器 描述：Parallel Old 是Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现CMS（Concurrent Mark Sweep）收集器(老年代收集器) 描述：一种以获取最短回收停顿时间为目标，基于标记-清除算法的收集器。 过程 初始标记（CMS initial mark）：标记GCRoots能直接关联到的对象，（STW） 并发标记（CMS concurrent mark）：从GCRoots能直接关联的对象开始遍历整个对象图的过程。 重新标记（CMS remark ）：修正并发标记的期间，标记变动的对象标记（STW） 并发清除（CMS concurrent sweep）：清理标记阶段死亡的对象 关联：增量更新 特点 并发标记和并发清理阶段，用户线程还在运行，标记过程结束后的产生的垃圾无法在本次GC清理，存在“浮动垃圾” 基于上一特点，CMS收集器存在启动阀值 如果在CMS垃圾回收过程中，预留内存无法满足程序分配内存的需要（Concurrent Mode Failure），会启动后备预案：冻结用户线程的执行，临时使用Serial Old 收集器来重新进行老年代的垃圾收集。Garbage First收集器 描述：面向服务端应用的垃圾收集器,JDK9服务端模式默认回收器 过程 初始标记：标记GCRoots能直接关联到的对象，STW 并发标记：从GCRoots开始对堆中的对象进行可达性分析。 最终标记：用于处理并发阶段结束后遗留的少量SATB记录，STW 筛选回收：根据各个Region的回收价值和成本进行排序，将需要回收Region的存活对象复制到空的Region,STW 特点： G1收集器面向整个Java堆，用来垃圾数量做衡量标准，使回收收益最大，Mixed GC模式 把连续的Java堆划分为多个大小相等的独立区域（region），每一region都可以成为Eden,Survivor,或者老年代空间，Region是最小回收单元，-XX:G1HeapRegionSize设定大小[1MB,32MB] 2^N次 G1还有一类Humongous区域用于存放大对象，一般当作老年代的一部分看待，判定标准：大于Region容量一半的对象 G1收集器会跟踪各个Region里的垃圾堆积的“价值”，在后台维护一个优先级列表，优先收集价值最大的Region。 从G1开始，最先进的垃圾收集器设计导向都不约而同地变为追求能够应付应用内存的分配速率。 存在问题和解决方案 跨Region引用问题：记忆集 哈希表：Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这样的结构内存消耗比较大，每一个Region都要有一份卡表，至少要消耗相当于Java堆容量10%至20%的额外内存来位置收集器工作， 并发标记时收集线程和用户线程冲突问题 G1为每一个Region设计两个名为TAMS（Top at Mark Start）的指针，把Region划分出来用于分配新对象，G1默认这个地址上的对象是隐式标记的。 如何建立停顿等待预测模型 -XX:MaxGCPauseMillis 制定垃圾收集之前的期望值。 衰减均值为理论基础：普通平均值更容易收新数据的影响，但是衰减平均值更加准确地代表“最近的”平均状态 低延迟垃圾收集器 衡量垃圾回收器的三项重要指标，“不可能三角” 内存占用 吞吐量 延迟Shenandoah 描述：和G1类似，基于Region的堆内存布局，同样有Humongous Region，支持和用户线程并发的整理算法，摈弃了G1中消耗大量内存的记忆集，改名为“连接矩阵”的全局数据来维护跨Region的引用关系（类似于图里面的邻接矩阵）。 过程 初始标记：标记和GCRoots直接关联的对象 并发标记：遍历对象图 最终标记：处理甚于的SATB 并发清理：清理没有一个存活对象的region 并发回收：复制存活对象到未使用的Region 初始引用更新：复制对象结束后，还需要把堆中的所有指向旧对象的引用修正到复制后的新地址，引用更新。初始引用更新只是一个线程集合点，确保回收阶段的收集器线程都完成了任务 并发引用更新：真正开始的引用更新。 最终引用更新：修正存在于GCRoots的引用 并发清理：最后并发清理回收集的Region 转发指针 实现对象移动和用户程序并发的解决方案 方案-1 通常是在被移动对象原有的内存上设置保护陷阱，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，由异常处理器中的代码逻辑把访问转发到复制后的新对象上。 会导致用户态频繁切换到核心态，代价大 Brooks（大佬）提出的新方案 在原有的对象布局结构的最前面同一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己 两次访问内存，存在开销，同时要保证对对象的写入只能发生在新的对象中（CAS实现）。ZGCZGC的内存布局 基于Region的堆内存布局 ZGC的Region具有动态性–动态创建和销毁 ZGC的Region可以分为大、中、小三类容量 小型Region：size固定：2MB,用于放置小于256KB的小对象 中型Region：size固定：32MB,用于放置大于等于256KB但小于4MB的对象 大型Region：容量不固定&gt;=4MB，可以动态变化，但是必须是2NMB,用于大于等于4MB的对象，不会被重分配染色指针技术 将标记信息记在引用对象的指针上 原理 在64位系统中理论可以访问的内存高达16EB但是处于成本和性能的考虑， 在AMD64架构中只支持到52位的地址总线和48位的虚拟地址空间 64位的Linux则分别支持47位的进程虚拟地址空间和46的物理地址空间，64位Window甚至只支持44位的物理地址空间 ZGC提取46位中的高4位来存储4个标志信息，意味着ZGC管理内存不能超过2^42B12345/*|-------Unused(18bit)------| Finalizable| Remapped | Marked1 |-Marked0-|-----------Object Address(42bit)-----------|*/ 染色指针优势 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用调（“自愈”特性） 减少内存屏障的使用 染色指针可以作为可拓展的存储结构来记录更多的对象标记 定义内存的可能性 X86实现：Linux平台上，ZGC使用多重映射，不同地址段映射到同一个物理内存空间。 ZGC过程 并发标记：可达性分析，更新染色指针中的Marked0、Marked 1标志位 并发预备重分配：根据特定的查询条件统计本次需要清理哪些Region，将这些Region组成重分配集，每次回收会扫描所有的Region，ZGC的分配集只是决定了里面的存活对象会被重新复制到其他的Region中 并发重分配：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录旧对象到新对象的转向关系，访问时预置的的内存屏障会被截获，同时修正其值 并发重映射：修正整个堆中指向重分配集中旧对象的所有引用，可自愈，不急迫 类文件结构无关性的基石 Class文件Class文件结构 Class文件以8个字节为基础单位的二进制流。 数据类型： “无符号数”：属于基本的数据类型，以u1、u2、u4、u8 “表”：所有表都以“_info”结尾，整个Class文件本质上也可以视作一张表魔数和Class文件的版本 常量池访问标志 u2:代表访问标志，和这个标志用于标志一些类或者接口层次的访问信息，包括Class是类还是接口，是否定义为public,abstract,final。使用位运算表示。类索引、父类索引和接口索引集合 u2:类索引 u2:夫类索引 u2:接口长度，u2:接口索引字段表集合 u2:access_flag，访问标志 u2:name_index，字段的简单名称：没有类型和参数修饰，全限定名：包名+类名，/ 分割 u2:descriptor_index，类型描述，如：java.lang.String[][] –&gt; ‘[[Ljava/lang/String;’ u2:attributes_count attribute_info:方法表集合 基本和字段表一致，访问标志符多了几个 属性表集合 u2: attribute_name_index,如code，exceptions等的 u4:attribute_length,1 u1:info,attribute_length 字节码指令简介字节码与数据类型 i(int),l(long),s(short),b(byte),c(char),f(float),d(double),a(reference)加载和存储指令 jvm虚拟机基于操作数栈的 \&lt;type>load_\:iload,iload_1,n为操作数栈顶的第n个操作数 \&lt;type>store_\:istore,istore_1运算指令 operator:add,sub,mul,div,rem(求余),neg(取反)，ish[l|r]移位指令, \&lt;type>operator类型转化指令 \&lt;type>2\ 小范围到大范围是安全的 浮点值转化为整数类型T: 如果浮点值是NaN，那转换结果就是int或者long类型对象创建与访问指令 创建类实例的指令：new 创建数组的指令：newarray,anewarray,multianewarray 访问类字段：getfield、putfiled、getstatic、putstatic 加载数组元素加载到操作数栈的指令,操作数栈的值存储到数组元素中\&lt;type>a(operator)，ballad、caload、saload、bastore 取数组长度：arraylength 检查类实例类型的指令：instanceof、checkcast操作数栈管理指令 操作数栈的栈顶一个或两个元素出栈：pop、pop2 复制操作数栈的栈顶一个或两个元素并且重新入栈：dup_x1、dup2_x2 互换栈顶两个元素：swap控制转移指令 条件分支：ifeq,iflt 符合条件分支 无条件分支：goto、goto_w、jsr、jsr_w、ret方法调用 invokevirtual指令：调用对象的实例方法 invokeinterface指令：调用接口方法，搜索一个实现了这个接口方法的对象 invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有化方法和夫类方法 invokestatic指令：调用类的静态方法 invokedynamic：运行时动态解析出调用点限定符所引用的方法异常处理指令 athrow同步指令 方法内部指令同步和方法级同步：使用管程(monitor，monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区)来实现。 方法级同步：虚拟机可以通过方法常量池中的ACC_SYNCHRONIZED访问标志，当方法调用时将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程。 synchronized：monitorenter，monitorexit。虚拟机类加载机制类加载时机 过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载 初始化时机：对一个类型进行主动引用触发初始化。 遇到new、getstatic、putstatic、invokestatic，如果类型没有被初始化，先触发初始化，对于静态字段，只有直接定义的类才会初始化。 遇到new实例化对象 读取或设置一个静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候 调用静态方法 初始化类时，同时初始化未初始化的父类。 虚拟机启动时，用户需要指定一个执行的主类，先要初始化这个类。 接口实现类初始化时，要先初始化接口类加载过程加载 虚拟机工作 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化方法区运行时的数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口 加载阶段可以通过自定义的类加载器控制获取字节流方式 重写一个类的类加载器的findClass()或loadClass()方法 loadClass和findClass的区别：整个类加载阶段分五步：加载、验证、准备、解析、初始化。classloader只负责第一步加载，loadClass遵循双亲委派模式0，Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块 对于数组类本身不通过类加载器创建，它是由Java虚拟机在内存中直接动态构造出来的。数组类的元素类型还是要靠类加载器，数组类创建规则： 如果数组的组件类型是引用类型，递归加载组件类型 数组的组件类型不是引用类型（如：int），Java虚拟机会把数组C标记为与引导类加载器关联 数组类的可访问性与它的组件类型一致。 加载结束后，加载的字节流按照虚拟机所设定的格式存储在方法区，同时生成java.lang.Class类的对象，这个对象将作为程序访问方法区中的数据类型的外部接口 验证 文件格式验证： 验证点 是否魔数开头 主次版本是否是Java虚拟机所接受的 常量池的常量中是否有不被支持的常量类型（tag标志） Class文件中的各个部分及文件本身是否有被删除或者附加的信息 目的 保证输入的字节流能正确解析并存储于方法区内 元数据验证 验证点 是否有父类 是否继承了不被允许继承的类 是否是抽象类，是否实现了其父类或者接口之中要求实现的所有方法 类中的字段、方法是否与父类产生矛盾（覆盖类父类的final字段，不符合规则的方法重载 目的 是否继承了不允许被继承的类 是否实现了父类或者接口要求实现的所有方法 对类的元数据进行语义校验，（个人理解：是否违背了Java面向对象的规则） 字节码验证 验证点 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作 跳转指令的合法性 类型转化的有效性（不合法如：父亲对象赋值给子类数据类型） 优化 减少数据流分析和控制流分析的消耗，将更多的校验挪到编译器里进行，新增StackMapTable StackMapTable:描述类方法体所有的基本块（按照控制流拆分代码块）开始时本地变量表和操作数栈的状态，使得字节码验证的类型推导变成了类型检查 符号引用验证 验证点 符号引用通过字符串描述的全限定名是否能够找到对应的类 指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段 符号引用中的类、字段、方法的可访问性是否可被当前类访问 目的 主要保证解析行为能够正常执行准备 为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（“0”值，被final修饰的话，会在这一阶段赋值为指定的值） 概念上分配在方法区，但是JDK8后类变量会随着Class对象一起存放在Java堆中。 解析 将Java虚拟机将常量内的符号引用替换为直接引用(定义：直接引用是可以直接指向目标指针、相对偏移量或者一个间接定位到目标的句柄) invokedynamic指令，符号引用多次解析不能保证是同一个实体 例子 类和接口的解析：对一个类D，将一个符号引用 N 解析为一个类或接口C的直接引用。 如果C不是一个数组类型，将符号引用N的全限定名递给D的类加载器去加载这个类C。 如果C是数组类型，并且数组类型为对象，则按照第一点的规则加载数组元素类型，然后由虚拟机生成一个代表数组维度和元素的数组对象 以上两点没有异常后检查D对C的访问权限 字段解析 解析字段表中的CONSTANT_Class_info符号引用，设所属的类或者接口为C 对C进行后续字段搜索 C包含了简单名称和字段描述符与目的字段相匹配的字段，则返回这个字段的直接引用，查找结束 如果没有，则向上查找（实现的接口和继承的类中查找，如果接口和类都有同一字段的话会冲突） 方法解析 和字段解析类似 接口方法解析 方法解析类似初始化 执行类构造器\&lt;clinit>()方法 &lt;clinit>()编译器自动收集类中的所有类变量的赋值动作和静态语句中的语句合并生成。 收集顺序由定义顺序决定，静态语句块只能访问到静态语句块之前的变量 &lt;clinit>()方法与类的构造函数不同，他不需要显示调用父类构造器，Java虚拟机会保证子类的&lt;clinit>()方法执行前，父类的方法已经执行完毕。 如果类没有静态语句块，也没有对变量的赋值操作，()方法不会生成 接口与类不同的是，执行接口的\&lt;clinit>()方法不需要先执行父接口的&lt;clinit>()方法，只有使用了父定义的变量，父接口才会被初始化 &lt;clinit>()方法是线程安全的 类加载器类与类加载器 比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义，否则两个类来源于同一Class文件，被同一个Java虚拟机加载，只要他们的类加载器不同，那这两个类就必定不相等。双亲委派模型 Java虚拟机两种类加载器：启动类加载器(C++实现)，其他类加载器(Java语言实现) 系统提供的类加载器 启动类加载器：加载&lt;JAVA_HOME&gt;\lib或者被-Xbootclasspath参数指定的路径中存放的类库 拓展类加载器：加载&lt;JAVA_HOME\&gt;\lib\ext目录中的或者被java.ext.dirs系统变量所指定的类库. 应用程序加载器：加载用户类路径上所有的类库，开发者可以直接在代码中使用这个类加载器 双亲委派模式 类加载器收到一个类加载的请求时，他首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此只有父类的加载器无法完成加载请求（他的搜索范围中没有找到所需要的类），子类才会去加载。 优点：保证Java的类和他的类加载器一起具备了带有优先级的层次，防止Java标准库中的类被用户定义的类覆盖模块下的类加载器： 维持三层加载器和双亲委派模式的架构 当平台及父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到归属，则优先委派给负责那个模块的加载器加载虚拟机字节码执行引擎概述 执行 解释执行：通过解释器执行 编译执行：编译生成本地代码执行运行时栈帧结构局部变量表 存放方法参数和方法内部定义的局部变量，Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量 变量槽：可以存放32位的数据 0号索引变量槽默认是用于传递方法对象实例的引用的 变量槽可以复用 局部变量没有赋初值不能使用操作数栈 概念上，两个不同的栈帧为不同的两个虚拟机栈的元素，完全独立，实现上会将下面栈帧的部分操作数栈和上面栈帧的部分局部变量表重叠在一起动态链接 指向运行时常量池中栈帧所属方法的引用。 符号引用一部分会在类加载阶段或者第一个使用的时候就被转化为直接引用，这被称为静态解析，另一部分将在每一次运行期间都转化为直接引用，这部分为动态连接。方法返回地址 方法执行后两种推出方法 执行引擎遇到任意方法返回的字节码指令 方法执行的过程中产生异常，本地方法的异常表中没有搜索到匹配的异常处理器，会导致方法推出。 方法退出等同于把当前栈帧出栈，因此退出可能执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧中的操作数栈中，调整PC计数器。方法调用解析 “非虚方法”：类加载的解析阶段，将一部分符号引用转化为直接引用，前提：方法在程序真正运行之前就有一个可以确定的调用版本，并且这个方法的调用在运行期是不可变的。invokestatic,invokespecial。 “虚方法”：分派 静态分派 静态类型：定义的字面类型，重载是通过静态类型作为判定依据，重载时如果没有找到准确的函数时，会自动类型转化，安全转型最优先。 动态类型：变量的实际类型 动态分派 方法调用通过动态分配： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 校验调用C类型的方法相关参数，访问权限是否相符合 否则从下向上依次对C的各个父类搜索和验证 Java只有虚方法存在，字段永远不可能是虚的，如果子类有父类一致的字段，子类会覆盖父类字段，但是内存同时存在 单分派与多分派 宗量 方法的接收者 方法的参数 Java语言属于动态分配属于单分派类型（方法接受者）前端编译概述 编译器类型 前端编译器：.java文件转变成 .class 文件，Javac 即时编译器：运行期间把字节码转变成本地机器码，HotSpot虚拟机的C1，C2编译器，Graal编译器 提前编译器：直接把程序编译成于目标机器指令相关的二进制代码Javac编译器编译过程 一个准备过程，3个处理过程 准备过程：初始化插入式注解处理器 解析于填充符号表过程，包括： 语法、语法分析。将源代码的字节流转变为标记集合，构造出抽象语法树 填充符号表。产生符号地址和符号信息 插入式注解处理器的注解处理 分析与字节码生成过程 标注检查：对语法的静态信息进行检查 数据流控制分析：对程序动态运行过程进行检查 解语法糖： 将简化代码编写的语法糖还原为原有的形式 字节码生成：将前面各个步骤所生成的信息转化成字节码Java语法糖泛型 Java的泛型：类型擦除式泛型–只在程序源码中（历史包袱问题） C#的泛型：具现代化泛型 类型擦除 裸类型：类型泛化实例的共同父类型 无法支持原始类型数据自动装箱、拆箱与遍历循环 包装类在不遇到算术运算的情况下不会自动装箱后端编译与优化即时编译器解释器和编译器编译对象与触发条件 热点代码： 被多次调用的方法 被多次执行的循环体 编译对象：整个方法体。 热点探测 基于采样的热点探测：虚拟机会周期性的地检查各个线程的调用栈顶。 基于计数器的热点探测：虚拟机为每一个方法（甚至是代码块）建立计数器，统计方法的执行次数（HotSpot采用） HosSpot的热点计数 两种计数器：方法调用计数器、回边计数器 方法调用计数器：客户端模式是1500次，服务端是10000次 执行机制 存在即时编译的版本时，优先使用编译后的本地代码来执行。 如果不存在被即时编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器和回边计数器之和是否超过方法调用计数器的阀值，一旦超过阀值的话，将会向即时编译器提交一个该方法的代码编译请求 热度衰减：方法调用计数器统计的是一个频率，如果一段时间内其值仍然没有超过阀值，那么调用计数器就会被减少一半（这段时间被称为此方法统计的半衰期），热度衰减 回边计数器：统计方法循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边”。目的：触发栈上的替换编译 回边计数器：执行机制与方法调用计数器差不多，但是没有计数衰减的过程编译过程 标志的编译请求：编译动作在后台的编译线程中进行 过程： 平台独立的前端将字节码构造成一种高级中间的代码表示（HIR,与目标机器指令无关），优化：方法内联，常量传播会在字节码构造成HIR之前完成 平台相关的后端从HIR中产生低级中间代码表示，优化：空值检查，范围检查消除等。 平台相关的后端使用线性扫描算法，产生机器码Java的内存模型与线程Java的内存模型 主内存和工作内存 每个线程都有自己的工作内存，线程私有 -&gt; 线程间通信问题 happens before原则 程序次序规则 管程锁定规则 volatile变量规则 线程启动规则 ….volatile使用 volatile字段的作用 保证变量对所有线程的可见性，不能保证运算的正确性，保证及时写回 禁止指令重排序，内存屏障作用，重排序不能越过内存屏障。 volatile读的内存语义 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 volatile重排序的限制 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 JMM内存屏障插入策略。 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 变量值不一致的原因 处理器不直接和内存通讯，而是先将系统内存的数据读到内部缓存（L1, L2 或者其他）后进行操作。 可见性的实现 被修饰的变量在编译成汇编代码会多一条Lock指令，将缓存的数据写回内存。 对于其他线程来说，每个处理器通过总线嗅探技术来判断缓存数据的有效性 Java对象头 对象头 长度 内容 说明 32/64 bit MarkWord 存储对象的hashCode或者锁信息等 32/64 bit Class Metadata Address 存储对象类型数据的指针 32/32 bit Array length 数组的长度(普通对象没有这一项) Mark Word64 位为8bytes Class Metadata Addres 64位默认开始指针压缩（+UseCompressedClassPointers），所以64位没有指定的时候还是32位 64位指针默认是：UseCompressedOops ，32位 12345➜ ~ java -server -XX:+PrintCommandLineFlags -version-XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GCjava version &quot;11.0.1&quot; 2018-10-16 LTSJava(TM) SE Runtime Environment 18.9 (build 11.0.1+13-LTS)Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.1+13-LTS, mixed mode) Java与线程线程实现 共享进程资源，轻量级进程 内核线程1:1 用户线程：1:NJava线程 1:1线程模型，直接映射到操作系统原生线程来实现Java线程调度 协同 or 抢占状态转化 New Runnable Waiting Blocked TerminatedJava与协程内核线程的局限 微服务的兴起，缩短了留给每个服务的响应时间 对于Java的线程模型而言：当请求本身执行时间短，但是数量变得多的时候，线程切换的开销会很大协程 内核线程的调度成本主要来自于用户态与核心态之间的状态切换，状态切换开销主要来自响应中断，保护和恢复执行现场的成本。 有栈协程 实现完整地做调用栈的保护、恢复工作。 无栈协程 await、async、yield关键字 有限状态机 协程 轻量 需要在应用层面实现的内容特别多 线程安全和锁优化线程安全 多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。线程安全实现方法 互斥同步 临界区，互斥量，信号量 Java实现管程： synchronized monitorenter monitorexit 机制：monitorenter指令时，首先去尝试获取对象的锁。获取后把锁计数的值增加一，执行monitorexit会将锁计数器减一，为零则释放。synchronized的实现 具体表现 对于普通的同步方法，锁为实例对象 对于静态同步方法，锁为当前对象的Class对象 对于同步方法块，锁是synchronized配置的对象重入锁ReentrantLock 等待可中断，等待线程可以选择放弃，改为处理其他事情 公平锁：按申请时间顺序来获得 锁定多个条件非阻塞同步 互斥同步：线程阻塞和唤醒性能消耗，属于阻塞同步 cmpxchg指令，CAS无同步方案 ThreadLocal: 每个Thread对象中都有一个ThreadLocalMap对象，ThreadLocal变量就是访问入口锁优化自旋锁与自适应自旋 自旋等待本身虽然避免了线程切换的开销，但是它要是占用处理器时间的，自旋时间过长会浪费系统资源 自适应自旋锁消除 通过逃逸分析，如果判断到一段代码中在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的。锁粗化 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围拓展到整个操作序列的外部 轻量级锁123456789|----------|----------------32bit-----------------------------------||--锁状态---|-----25 bit------|---4bit---|-----1bit----|----2bit-----||----------|--23bit--|-2bit--|----------|---偏向模式---|----标志位----||--未锁定---|-----对象哈希码----|-分代年龄--|------0------|-----01------||-轻量级锁定-|---------指向调用栈中锁记录的指针-------------|-----00------||-重量级锁定-|------------指向重量级锁的指针---------------|-----10------||--GC标记---|------------------------------------------|-----11------||--可偏向---|-线程ID-_|-Epoch-|--分代年龄--|------1------|-----01------| 工作机制 代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志为 00），虚拟机在当前栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的MarkWord的拷贝 然后虚拟机使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果更新成功了，即代表线程拥有了这个对象的锁，并且对象Mark Word的锁标志变为“00” 如果CAS失败，说明至少有一个线程和当前线程竞争获取该对象的锁，检查对象的MarkWord是否指向当前的栈帧，如果当前线程已经拥有锁了，直接进入同步代码块 如果出现两条以上线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁，锁标志的状态值变为 “10” 此时MarkWord存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。偏向锁 锁会偏向第一个获得它的线程，如果接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要在进行同步。 工作机制 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志设置为“01”,把偏向模式设置成 “1”，同时使用CAS把获取到的这个锁的线程的ID记录在Mark Word中 一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上结束，如果对象处于被锁定，则变为轻量级锁，没有则变为未锁定 hashCode问题：对象头中存储的对象头保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生变化，当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，他的偏向状态被立即撤销，并且会膨胀为重量级锁，在重量级锁ObjectMonitor类里有字段可以记录非加锁状态下的MarkWord。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关知识笔记]]></title>
    <url>%2F2020%2F02%2F07%2Fdb%2F</url>
    <content type="text"><![CDATA[DataBase DataBase索引的一篇文章ACID 数据库事务四大的特性 原子性(Atomicity) 一致性(Consistency) 独立性(Isolation) 持久性(Durability) 索引的类型 哈希索引 B_tree Full-text索引 聚集索引和非聚集索引主键和唯一索引的区别 主键是一种约束，唯一索引是一种索引 主键唯一标识一列，索引用于优化查找索引的优点 加快了数据检索的速度，减少查询时间索引的缺点 创建索引需要耗费时间 索引需要占据物理空间 索引失效 简单地说就是给出的筛选条件需要对每一个元素进行判断，或者需要加工（调用函数）数据再判断的情况下，索引就会失效 使用 !=时 mysqlMysqldump123Usage: mysqldump [OPTIONS] database [tables]OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]OR mysqldump [OPTIONS] --all-databases [OPTIONS] 1mysqldump -uroot -p*** --databases DBName &gt; dest_file 条件导出 1mysqldump -uroot -proot --databases db1 --tables a1 --where=&apos;id=1&apos; 事务级别 为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。 read uncommitted –&gt;脏读 read commited –&gt;不可重复读，防脏读，存在幻读 repeatable read,用户当前会话可以重复读，就是每次读取的结果都相同，不管其他事务有没有提交 serializable 串行化 编码问题 utf8mb4：mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。 mysql引擎 MyISAM较高的插入，查询速度，担不支持事务，B+tree作为索引结构，索引文件仅仅保存地址 InnoDB,支持事务，行锁定和外键。数据文件本身就是索引文件 InnoDB表数据组织方式是主键聚簇索引。二级索引通过索引键值加主键值组合来唯一确定一条记录 Memory储存引擎，内存 ArchiveBTree和B+Tree MVCC MySQL中 InnoDB 引擎支持 MVCC MVCC在Read Committed和Repeatable Read起作用 MVCC逻辑流程 在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列 数据行的版本号 6bytes（DB_TRX_ID） 删除版本号 7bytes(DB_ROLL_PT) DB_ROW_ID(6bytes) 如何实现一致性读 —— 在 RR 隔离级别下，每个事务 touch first read 时（本质上就是执行第一个 SELECT 语句时，后续所有的 SELECT 都是复用这个 ReadView 在 RC 隔离级别下，每个SELECT 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 ReadView ReadView中是当前活跃的事务ID列表，称之为m_ids InnoDB MVCC的实现 Undo log Undo log可以用来做事务的回滚操作，保证事务的原子性。同时可以用来构建数据修改之前的版本，支持多版本读 undo log是指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log),rollback 利用这个还原 Redo log 它是将事务操作的最新数据存储起来, 主要是为了实现事务的持久性而产生的, 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性 Read View m_low_limit_id： 事务ID大于等于该值的数据修改不可见 m_up_limit_id：事务ID小于该值的数据修改可见 WAL实现一致性 窍门在于 WAL 是顺序写入的一直在文件末尾 append，而持久化数据库的数据是一个随机写入操作，顺序写会节省大量的磁盘悬臂来回寻址的过程，效率要高好几个量级。 SQL常见统计 基本统计：count() group by 严格模式下，聚合函数不能用非聚合的字段 排序：order by field asc(desc) 剔除：having condition 包含 where condition like ‘李%’ ##SQL 语句 join 博客 left join table on condition 1select Student.Sid,Student.Sname,t1.sumscore,t1.coursecount from Student left join(select SC.Sid, sum(SC.score) as sumscore ,count(SC.Cid) as coursecount from SC group by SC.SID) as t1 on Student.Sid=t1.Sid; HAVING 123456select student.*,t1.avgscorefrom student inner JOIN(select sc.SId ,AVG(sc.score)as avgscorefrom sc GROUP BY sc.SIdHAVING AVG(sc.score)&gt;=60)as t1 on student.SId=t1.SId 批处理 1234# 设定结束符号 delimiter ; create procedure load_t (count int unsigned) begin set @c=0; while @c &lt; count Do insert into t select null,repeat(char(97+rand()*26),10); set @c=@c+1; end while; end;$$ 日期操作(类型为date的column)比较 datediff(date1,date2) 比较date1和date2相差的天数，有正负 timestampdiff(time_unit,date1,date2) time_unit指定结果单位，如比较日期天数(day,date1,date2)]]></content>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS]]></title>
    <url>%2F2020%2F01%2F01%2FOS%2F</url>
    <content type="text"><![CDATA[操作系统学习笔记 进程及进程管理进程 简单地说：进程是计算机系统有限资源地基本单位，在不支持线程的处理机上是调度的基本单位(否则是线程) 进程的状态变化 运行 就绪 等待 状态变迁图: 进程的控制 功能 进程控制 进程调度 进程间的同步协调 进程创建(操作原语) 过程 形成进程控制块PCB，填充进程标识符，进程优先级(PCB块并不是创建时才生成，系统会维持一个PCB池，空闲时PCB进程标识符存放 ‘-1’) UNIX 或Linux系统中，父进程创建子进程时，该子进程继承父进程占用的系统资源，以及除进程内部系统标示符以外的其他特性 UNIX和Linux系统创建进程及应用实例(调用fork系统调用) 分配PCB 为子进程分配一个唯一的PID(进程标识号) 拷贝父进程数据段(不会有多线程线程修改父进程的变量的危险操作)和堆栈段数据到新的主存区，正文段(代码段)引用计数+1(即共享代码段) 增加与进程相关联的文件表和索引节点表的引用数，即子进程可以使用父进程打开的文件 子进程返回0,父进程返回子进程进程号(PID)进程和线程具体使用 github仓库进程撤销 归还PCB -&gt; PCB资源池，占用资源 -&gt; 父进程 转进调度程序进程等待 CPU现场保留至PCB现场保护区 PCB插入到等待队列进程唤醒 被唤醒，转为就绪态 PCB插入就绪队列 进程之间的约束关系 互斥 -&gt; 存在临界区 同步 -&gt; 进程执行有顺序限制 同步机构 操作系统提供的同步机构 锁 信号灯(信号量) 和P,V操作 锁 可以把它想像成现实生活中的锁，机制是差不多的。 信号灯 一组确定的二元组(s,q) P操作，以P(s)为例 s减1 如果结果 &gt;= 0 ,则进程继续执行 小于0，线程被封锁，并将它(前面提到过，这里插入的是进程的PCB)插入到该信号灯的等待队列中，然后进入调度程序 V操作，以V(s)为例 s值加1 如果结果大于0，进程继续执行 如果结果小于或者等于零，则从该信号灯的等待队列中移除一个进程，解除它的等待状态，然后返回本进程继续执行 V操作不会使当前线程状态变化 线程互斥和同步的实现 总的来说，常见的就那么几种，直接举几个用信号灯实现的例子 简单互斥1234567891011121314151617181920// 伪代码// 这里定义cobegin 和coend之间的程序是同时执行的//main()&#123; int mutex = 1 ; cobegin p_a(); p_b(); coend &#125;p_a()&#123; p(mutex) // do something v(mutex)&#125;p_b()&#123; p(mutex) // do something v(mutex)&#125; 简单的先后123456789101112131415161718192021222324 // 伪代码，一个看病的例子，先看病，再化验，最后诊断 main()&#123; int s1 = 0; int s2 = 0; cobegin labora(); diagnosis(); coend &#125;labora()&#123; while(化验工作未完成)&#123; p(s1); 化验工作; v(s2); &#125;&#125;diagnosis()&#123; while(看病工作未完成)&#123; 看病; v(s1); p(s2); 诊断 &#125;&#125; 多级先后关系 实现思路和简单先后的思想差不多，如果要让线程-1在另外一个线程-2后面执行，只需要控制信号灯的值在线程-1 执行完之前都小于等于0即可 生成者消费者问题123456789101112131415161718192021222324252627282930313233// 一个有界缓冲区 多个消费者度，多个生产者写问题// _ _ _ _ _ _ _ _ // 读 &lt;-- | | | | | | | | &lt;-- 写// &lt;-- |_|_|_|_|_|_|_| &lt;-- main()&#123; int full = 0; //缓冲区可读的缓冲块数目 int empty = n; // 缓冲区可写的缓冲区数目 int mutex = 1; // 同时只能有一个线程能够写/读缓冲区 cobegin p1();p2();p3();pk(); c1();c2();c3();ck(); coend&#125;producer()&#123; while(/*生产未完成*/)&#123; //生产一个产品; p(empty); p(mutex); // 写一个缓冲块 v(mutex); v(full); &#125;&#125;consumer()&#123; while(/*还要继续消费*/)&#123; p(full); p(mutex); // 读一个缓冲块; v(mutex); v(empty); &#125;&#125; 4.7进程通信进程通信的几种方式 消息缓冲通信 在进程的主存空间设置一个接收区，然后用接收原语(原语可以理解为原子性操作，即操作不可分割)接收消息。 信箱通信 用户空间信箱 系统空间信箱线程 概念提出 -&gt; 为了进一步提高系统的并行处理能力 线程描述 线程是进程的一条执行路径 私有堆栈和处理机环境(PC,CPU运行时间,寄存器) 共享父进程的主存(想一下和子进程的区别？) 任务调度的基本单位(一般地，进程是系统资源分配的基本单位，线程是系统调度的基本单位)内核线程和用户线程 内核线程由操作系统支持，运行在内核空间 用户线程是在内核的支持下，在用户层通过线程库实现(即用户态线程和内核线程不一定是1:1，也有可能是多对一)。Linux下进程和进程管理 Linux下面，线程被视为一个与其他进程共享某些资源的特殊进程 PCB -&gt; task_struct 进程状态基本和上述一致，但是等待状态有TASK_INTERUPTIBLE和TASK_UNINTERUPTIBLE，即是和否可以被中断改变其等待状态 Linux查看当前系统启动时间 top w uptime fg,bg,ctrl+z,jobs fg +作业号，将后台程序调度到前台 bg 与fg相反 ctrl+z将程序挂起 jobs查看正在运行的任务tar -c:compress，打包 -x:extract, 提取 -g:gzip，提取或压缩 -j:bzip2，提取或压缩 -v:verbose(详细)，显示指令执行过程 -f:指定提取或压缩后的文件名以及位置软链接和硬链接 硬链接和文件本身的inode号是一样的 相当于软链接是保存链一个绝对路径 Linux查看进程命令 processes Statistic ps -aux 查看系统所有的进程 ps -IA 查看所有系统的数据 pa axif 连通部分进程树状态 pstree top 进程间通讯 信号量 信号 管道 socket 消息队列 共享内存(最快) 文件锁进程间的比较 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 一些细节操作系统中 heap 和 stack 的区别 栈:由操作系统自动分配释放，存放函数的参数值，局部变量的值等。 堆:一般由程序员分配释放，若程序员不释放，程序结束后OS自动回收 栈使用的是一级缓存，堆使用的是二级缓存。]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F04%2F11%2Fredis%2F</url>
    <content type="text"><![CDATA[1读《redis in action》笔记 redis事务事务型流水线关键指令 MULTI:声明事务 WATCH: 在事务过程中观察指定键值 EXEC:执行事务 DISCARD: 在WATCH后执行，取消WATCH和清空已经进入事务队列的命令 非事务型流水线 1conn.pipeline(False) 当命令的执行结果不影响另外一个命令输入时，可以不使用MULTI和EXEC执行事务 减少了应用程序和redis之间的通讯次数,可以提升redis性能 redis 性能测试 123redis-benchmark -c 1 -q# -c client 只选定一个client进行测试# -q简化输出 性能问题 单个客户端达到redis-bench 的50%-60% 的性能 不使用流水线的预期 性能达到25%-30% 对于每个指令都使用了新的连接构建应用程序组件自动补全简单自动补全 维护一个列表 在push联系人之前先删除该联系人，将其放在最前面 减枝利用有序集合的特性 利用有序集合的特性来减少排序的开销 12345678127.0.0.1:6379&gt; zrange complete 0 -11) "abc"2) "abc`"3) "abcd"4) "abce"5) "abcz"6) "abc&#123;"7) "c" 通过讲每个元素的分值设置为0，则通过ASCII编码排序 其他的语言原理是一样的构建分布式锁 简易锁 1234567891011121314import timeimport uuiddef acquire_lock(conn,lockname,acquire_timeout= 10): identifier = str(uuid.uuid4()) end = time.time()+acquire_lock while time.time()&lt;end: if conn.setnx('lock:'+lockname,identifier): return identifier time.sleep(0.01) return False''' 问题 1.当前锁失效后会有很多线程去请求锁，会出现多个线程获取锁的情况 2.锁的持有者崩溃后不会自动释放''' 带超时的锁 123456789101112131415161718import uuidimport mathimport time def acquire_lock_with_timeout(conn,lockname,acquire_time = 10,lock_timeout=10):identifier = str(uuid.uuid4())lockname ='lock:'+ locknamelock_timeout = int(math.ceil(lock_timeout))end = time.time()+acquire_timewhile time.time()&lt;end: if conn.setnx(lockname,identifier): conn.expire(lockname,lock_timeout) return identifier elif not conn.ttl(lockname): #防止持有锁的线程崩溃 conn.expire(lockname,lock_timeout) time.sleep(0.001)return False 锁的几个关注点 锁的持有者 锁持有者崩溃 锁的持有者超时计数信号量 Redis设计与实现事件 redis的事件分为两种：文件事件和时间事件 文件事件 基于Reactor模式的网络事件处理器，使用I/O复用来监听多个套接字 文件处理器的组成 尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字 I/O多路复用的实现 Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的 evport &gt; epoll &gt; kqueue &gt; select 事件类型 AE_READABLE事件 客户端对套接字执行write操作，或者执行close操作，会在服务端产生AE_READABLE事件 新的可应答（acceptable）套接字出现 AE_WRITABLE事件 客户端对套接字执行read操作，会在服务端产生AE_WRITABLE事件 文件事件处理器 连接应答处理器。 服务器对客户端的连接请求进行应答 命令请求处理器 服务器接收客户端发来的命令请求 命令回复处理器 服务器向客户端发送命令回复 复制处理器。 当主服务器和从服务器进行复制操作时 时间事件 定时事件 周期性事件 实现 一个时间事件主要由以下三个属性组成： id：服务器为时间事件创建的全局唯一ID（标识号）,ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。 when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。 timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。 服务器将所有时间事件都放在一个无序链表(指不按when的大小排序)中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器 正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以无序不会影响性能 时间事件应用实例：serverCron函数 持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。 清理数据库中的过期键值对 关闭和清理连接失效的客户端。 尝试进行AOF或RDB持久化操作。 如果服务器是主服务器，那么对从服务器进行定期同步 如果处于集群模式，对集群进行定期同步和连接测试 Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron，2.6为100毫秒运行一次，2.8开始可配置 事件调度 伪代码 processFileEvents()是虚构的，在实际中，处理已产生文件事件的代码是直接写在aeProcessEvents函数里面的 事件调度原则 aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间 因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了 对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，所以为了减少程序阻塞的时间，有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms]]></title>
    <url>%2F2019%2F03%2F18%2Falgorithms%2F</url>
    <content type="text"><![CDATA[复习算法，还没有看完，先总结一波（算法怎么看得完QAQ 函数增长 上界函数$$ 0 \leq f(n) \leq cg(n)$$$$ f(n) = O(g(n))$$ 下界函数$$ cg(n) \leq f(n) $$$$ f(n) = \Omega(g(n)) $$ 渐进紧确界函数 $$ c_{1}|g(n)| \leq |f(n)| \leq c_{2}|g(n)| $$ $$ 即f(n) = \Theta(g(n)) $$ 时间复杂度 多项式时间：可用多项式函数对计算时间界限的算法$$ \Omicron(1) &lt; \Omicron(logn)&lt;\Omicron(nlogn)&lt; \Omicron(n^{2})&lt;\Omicron(n^{3})$$ 指数时间：计算时间用指数函数界限的算法$$ \Omicron(2^{n}) &lt; \Omicron(n!) &lt; \Omicron(n^{n})$$ 测试用例常见数组 &amp;&amp; 链表 空数组 值全相同的 长度为1，2的数组，值相同，值不同。 正常的测试数组 数字运算转化为字符串问题 正数，负数 最好变成绝对值来做 链表问题翻转123456789101112131415161718192021222324252627282930313233343536//头插入的方式翻转链表ListNode* reverseList(ListNode* head) &#123; if(head == nullptr)&#123; return head; &#125; //使用一个哨兵，减少逻辑的判断 ListNode* flag = new ListNode(0); flag-&gt;next = head; while(head-&gt;next != nullptr)&#123; ListNode* tmp = head-&gt;next ; head-&gt;next = head-&gt;next-&gt;next; tmp-&gt;next = flag-&gt;next; flag-&gt;next = tmp; &#125; return flag-&gt;next; &#125;//用游标的方式翻转ListNode* reverseList(ListNode* head) &#123; if(head == nullptr || head-&gt;next == nullptr)&#123; return head; &#125; ListNode* tail = nullptr; ListNode* mid = head; ListNode* next = head-&gt;next; while(next != nullptr)&#123; mid-&gt;next = tail; tail = mid; mid = next; next = next-&gt;next; &#125; // 最后一个位置需要修复。 mid-&gt;next = tail; return mid; &#125; 分治法基本思想 将原本的问题分为几个规模较小的，但类似的原问题的子问题，递归地求解这些子问题，再合并。 分解，解决，合并例子 归并排序 $$ T(n) = 2T(n/2) + cn = \Omicron(nlogn) $$ 最近点对 小于等于三个元素时，比较得出最小的点对 大于等于三时，先二分，然后再划定最小区间，在区间内更新最小值 $$ T(n) = 2T(n/2) + nlog^2n $$ 最大子数组问题 交叉的情况：从中间向两边扩散 不交叉，递归求解 $$ T(n) = \Theta(nlgn)$$ 矩阵求递归式 代换法 看递归式猜测解 代入用数学归纳法证明 $$ 如：T(n) = 2T([n/2])+n \ 猜测其解为\Omicron(nlogn) \ 代入 \ T(n) \leq 2(c[n/2]log([n/2])) + n \ \leq cnlog(n/2) +n\ = cnlogn -cnlog2 +n\ = cnlogn -(c-1)n$$ 递归树法 画出递归树，求节点，总代价即为节点的代价和 主方法 $$ T(n) = aT(n/b)+f(n)\ 如果 \epsilon &gt; 0 f(n) = \Omicron(n^{log_{b}a-\epsilon}) 则T(n)=\Theta(n^{log_{b}a})\ 若 f(n) = \Theta(n^{log_{b}a}) 则T(n) = \Theta(n^{log_{b}a}logn)\ 若 \epsilon &gt; 0 有 f(n) = \Omega(n^{log_{b}a}logn),同时 af(n/b) \leq cf(n),则T(n) = \Theta(f(n))$$ 排序 冒泡排序 这个应该是最简单的了，直接贴代码好了 插入排序 类似于抽牌排序的过程 归并排序 借用二分的思想，当分成只有一个元素的片段时就已经是排好序了 合并就类似于链表的合并，但是需要额外开辟空间 堆排序 buildTree，从右边数第一个叶子结点的父节点开始建树， 123456789101112131415161718for(int i=nums.length/2-1;i&gt;=0;i--)&#123; heapify(i); &#125;public void maxHeapify(int index)&#123; int left = 2*index +1; int right = 2*index+2; int max = index; if(left&lt;this.heapSize&amp;&amp; num[left]&gt;num[max])&#123; max = left; &#125; if(right&lt;this.heapSize&amp;&amp; num[right]&gt; num[max])&#123; max = right; &#125; if(max!=i)&#123; swap(max,i) maxHeapify(max) &#125;&#125; ​ 建堆完毕后，取出最大值后重新建堆即可 123456789public void sort()&#123; maxTreeBuild(); for(int i = num.length-1;i&gt;=0;i++)&#123; this.heapSize-- swap(i,0); maxHeapify(0); &#125;&#125; 概率分析中位数和顺序统计概念*第i个顺序统计量是该集合中第i小的元素 中位数 odd: i= (n+1)/2 oven: ave([(n+1)/2]+[(n+1)/2+1])选择第k小元素 排序 选择 quicksort_partition函数 步步紧逼最大值和最小值 遍历即可 中位数问题 一维的中位数问题 带权中位数问题 查找问题二分查找中间点问题 mid = (high+low)/2,mid = low + (high-low)/2 理论上是没有问题的，但是，第一个中间点求解方法会导致溢出，或者说更容易溢出。 动态规划例子 切钢条$$ p[n]_{0 \leq i \leq n} = p[i]+p[n-i]$$ 矩阵链相乘 长度从 2 到n逐渐变大$$ f(x)= \left{\begin{aligned} 0 &amp;&amp; i==j \\ min_{i \leq k &lt; j}\{m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j}\} \end{aligned} \right.$$ 最优二叉搜索树 区间递增 $$ e[i,i-1] = q_{i-1}\ \omega[i,i-1] = q_{i-1}$$ $$ e[i,r-1] + e[r+1,j] + \omega[i,j] $$ 字符串问题截取字符串板子12345678while(index &lt; chars.size())&#123; int cur = index; //chars[index] == chars[cur] 可以替换成串的分类依据 while(cur &lt; chars.size() &amp;&amp; chars[index] == chars[cur])&#123; cur++; &#125; index = cur; &#125; 进制转化10 进制 变成每位数字范围为0-m-1进制 输入一个数A/m -&gt; A , A%m -&gt; k 如果是每位的范围是1～m (A-1)%m+1 -&gt; 每位的值 (A-1)/m -&gt; A 数组操作变换 旋转 位运算翻转 1234//，每8个比特翻转一下，其他类似推导n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8)// 奇数偶数位交换n = ((0xaaaaaaaa &amp; n) &gt;&gt; 1 )|((0x55555555 &amp; n) &lt;&lt; 1); 字符串 如果范围只是26个字母，可以考虑用位运算 1234//记录一个字符串中出现的字符for(int i=0;i&lt;s.size();i++)&#123; bit_mask1 |= 1 &lt;&lt; (s[i] - 'a');&#125; 数论总的来说 如果题目限制了用循环，那么说明肯定有规律可循 可以用连续的数据推一下。 树根 数的每个位上的数字相加 公式: $(num-1) mod (9) +1$ DFS最大岛问题 基准：不能越界 重复遍历：设置标记 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;private: int col_size = 0; int row_size = 0;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if(grid.size() == 0 || grid[0].size() == 0)&#123; return 0; &#125; int res = 0; row_size = grid.size(); col_size = grid[0].size(); for(int i=0;i&lt;row_size;i++)&#123; for(int j=0;j&lt;col_size;j++)&#123; if(grid[i][j] == '1')&#123; res++; dfs(grid,i,j); &#125; &#125; &#125; return res; &#125; void dfs(vector&lt;vector&lt;char&gt;&gt; &amp; grid,int row,int col)&#123; if(row &lt; 0 || col &lt; 0 || row &gt;= row_size || col &gt;= col_size)&#123; return ; &#125; if(grid[row][col] == '0')&#123; return; &#125; grid[row][col] = '0'; dfs(grid,row+1,col); dfs(grid,row-1,col); dfs(grid,row,col+1); dfs(grid,row,col-1); &#125;&#125;; 最大的岛面积 一次dfs ，重点判断重复 岛的数量填岛后的面积 一次dfs，同时记录下岛的面积，将返回的结果重置为最大岛面积 第二次遍历，对一个海洋区域，计算与其相邻的不同岛屿的面积总和]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network]]></title>
    <url>%2F2019%2F02%2F27%2Fnetwork%2F</url>
    <content type="text"><![CDATA[常见问题ping ICMP(internet Control Message Protocol)http和https的区别 http = http+ssl http端口80，https端口443 http为明文传输 https过程：* 客户端请求公钥，同时验证公钥 * 验证成功，客户端通过公钥加密客户端的生成的随机值，通过这个随机值进行加密解密 https会是页面加载时间延长50%，增加10%～20%的耗电TCP 三次握手目的：信息对等和防止超时; 四次握手目的 TCP连接断开过程：1、客户端TCP模块在收到应用程序的通知后，发送FIN，seq=x。2、服务器收到FIN报文段，发送ACK，确认号=x+1，并且通知应用程序客户端关闭了连接。客户端收到ACK报文段。3、服务器端的应用程序通知TCP关闭连接，服务器端TCP发送FIN+ACK，seq=y，确认号=x+1（这里ACK只是一般性的捎带ACK，TCP总是这样，以增强健壮性，反正也不费力气，从原理上说，对连接断开不是必须的）。4、客户端收到FIN+ACK报文段后，发送ACK，确认号y+1。服务器收到ACK报文段后，连接断开。 第二步是不能省略的 因为，第二步中，服务器端通知应用程序并获得反馈信息可能需要可观的时间，这可能涉及人机交互操作，也可能服务器应用层暂时还不想关闭连接。第二步结束后，服务器还可以继续通过这条连接发送数据给客户端，客户端已经不能发送数据了，但是仍然可以回复ACK。第二步中服务器立即发送确认是为了防止客户端重传FIN报文。 time_wait 2msl： 保证这次连接的重复数据段从网络中消失 保证TCP协议的全双工连接能够可靠关闭 CDN原理 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 套接字 一个套接字准备好读（满足任一）。 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓存区低水位。对于TCP和UDP套接字而言，缓冲区低水位的值默认为1。那就意味着，默认情况下，只要缓冲区中有数据，那就是可读的。我们可以通过使用SO_RCVLOWAT套接字选项(参见setsockopt函数)来设置该套接字的低水位大小。此种描述符就绪(可读)的情况下，当我们使用read/recv等对该套接字执行读操作的时候，套接字不会阻塞，而是成功返回一个大于0的值（即可读数据的大小）。 该连接的读半部关闭（也就是接收了FIN的TCP连接）。对这样的套接字的读操作，将不会阻塞，而是返回0（也就是EOF）。 该套接字是一个listen的监听套接字，并且目前已经完成的连接数不为0。对这样的套接字进行accept操作通常不会阻塞。 有一个错误套接字待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回了一个错误），同时把errno设置成确切的错误条件。这些待处理错误(pending error)也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。 一个套接字准备好写的条件（满足任一）。 该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓存区低水位标记时，并且该套接字已经成功连接（UDP套接字不需要连接）。对于TCP和UDP而言，这个低水位的值默认为2048bytes，而套接字默认的发送缓冲区大小是8k，这就意味着一般一个套接字连接成功后，就是处于可写状态的。我们可以通过SO_SNDLOWAT套接字选项（参见setsockopt函数）来设置这个低水位。此种情况下，我们设置该套接字为非阻塞，对该套接字进行写操作(如write,send等)，将不阻塞，并返回一个正值（例如由传输层接受的字节数，即发送的数据大小）。 该连接的写半部关闭(主动发送FIN包的TCP连接)。对这样的套接字的写操作将会产生SIGPIPE信号。所以我们的网络程序基本都要自定义处理SIGPIPE信号。因为SIGPIPE信号的默认处理方式是程序退出。 使用非阻塞的connect套接字已建立连接，或者connect已经以失败告终。即connect有结果了。 有一个错误的套接字待处理。对这样的套接字的写操作将不阻塞并返回-1（也就是返回了一个错误），同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。 close和shutdown的区别 shutdown破坏读/写连接 close减引用计数 UNIX Domain Socket 用于IPC,不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。UNIX Domain Socket有SOCK_DGRAM或SOCK_STREAM两种工作模式，类似于UDP和TCP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱 创建 1socket(AF_UNIX,SOCK_DGRAM,0); 因为应用于IPC，所以UNIXDomain socket不需要IP和端口，用文件路径来表示“网络地址” UNIXDomain socket用结构体sockaddr_un表示，是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。 UNIX Domain Socket客户端一般要显式调用bind函数，而不象网络socket一样依赖系统自动分配的地址 IP地址类型 IP: 网络ID+主机ID A类地址 一个字节网络ID+3字节主机地址构成 网络地址最高位为 0 range: 1.0.0.0–126.0.0.0 B类地址 2个网络IP地址+2个主机地址 网络地址最高位为 10（即:128的二进制10000000) range:128.0.0.0–191.255,255,255 C类地址 3byte网络地址+1byte主机地址 最高位 110 range: 192.0.0.0–223.255.255.255 D类地址 广播地址保留地址 A类保留地址10.0.0.0–10.255.255.255 B类保留地址172.16.0.0–172.31.255.255 C类保留地址192.168.0.0–192.168.255.255广播地址 主机位置1 如果有子网隐码如：/17,则后17置为1;线材 双绞线Max:100m 同轴电缆:1000m HTTP2 Google的一篇博客 HTTP3 epoll、poll、selectI/O模型 转发博客 IO方式 同步IO和异步IO的区别就在于：数据访问的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回I/O多路复用 内核发现进程指定的一个或多个I/O条件满足时，就通知进程。 select是POSIX定义的，epoll是Linux所特有select 特点 bitmap的原因文件描述符有限 数据频繁的内核和用户态之间的拷贝 需要轮询fd数组 poll 特点 链表存储，监听的文件描述符没有限制 需要轮询epoll 特点 epoll使用一个文件描述符管理多个描述符 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目 IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数 epoll_wait阻塞等待内核通知。ET和LT模式 默认采用LT模式，LT支持阻塞和非阻塞套，ET模式只支持非阻塞套接字，其效率要高于LT模式 LT的读写模式 LT对于read操作比较简单，有read事件就读，读多读少都没有问题 一般来说socket在空闲状态时发送缓冲区一定是不满的，假如fd一直在监控中，那么会一直通知写事件，不胜其烦，所以必须保证没有数据要发送的时候，要把fd的写事件监控从epoll列表中删除，需要的时候再加入回去 ET的读写操作 fd可读则返回可读事件，若开发者没有把所有数据读取完毕，epoll不会再次通知read事件 若发送缓冲区未满，epoll通知write事件，直到开发者填满发送缓冲区，epoll才会在下次发送缓冲区由满变成未满时通知write事件 ET模式下accept存在的问题，多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理，解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环 ET模式的线程饥饿问题 如果某个socket源源不断地收到非常多的数据，在试图读取完所有数据的过程中，有可能会造成其他的socket得不到处理，从而造成饥饿问题 LE和ET场景 在很容易触发EPOLLOUT，则使用ET，ET模式下，当再次epoll返回EPOLLOUT事件时，继续写出待写出的数据，当没有数据需要写出时，不处理直接略过即可。而LT模式则需要先打开EPOLLOUT，当没有数据需要写出时，再关闭EPOLLOUT（否则会一直返回EPOLLOUT事件） EPOLLSHOTONE A线程读完某socket上数据后开始处理这些数据，此时该socket上又有新数据可读，B线程被唤醒读新的数据，造成2个线程同时操作一个socket的局面 ，EPOLLONESHOT保证一个socket连接在任一时刻只被一个线程处理 如果对描述符socket注册了EPOLLONESHOT事件，那么操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次。想要下次再触发则必须使用epoll_ctl重置该描述符上注册的事件，包括EPOLLONESHOT 事件 epoll惊群问题 但是在epoll中仍然存在惊群问题，表现起来就是当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。 ###关于Reactor和PProactor模式 知乎问题 两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler 不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(read/write)]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[person_summary.md]]></title>
    <url>%2F2018%2F12%2F24%2Fperson-summary-md%2F</url>
    <content type="text"><![CDATA[web学期总结 1.回（chan)顾(hui)框架和语言and tools Javascript: nodeJs(别的不多说了，贴一张图)和express框架，微信小程序，Vue，mongodb。 Java: Java的基础部分都过了一遍，Spring这套东西还在看。 Python: 平时写算法的时候用，没有进一步的深入学习。Flask框架路由映射的实现，没事写写爬虫(写的都是些玩具。) Go: …算了吧，连官方文档都没有看完。 Docker: Docker image 的构建，Docker微服务的使用 SSH：凑合用吧，能够满足基本需求 Nginx: 基本的反向代理，负载均衡，没有深入学习。 计算机基础 《http权威指南》看到了加密部分。(貌似全忘了。。。) 《计算机网络自顶向下》，看到网络层了的BGP(Border Gateway Protocol)，这一章看的很懵X。 LeetCode算题 《深入理解计算机系统》,看到第二章节了。 《数据库系统设计与原理》，算了，不说了，绪论才看完。 算法：dp算法，分治法。红黑树二叉树(实现代码还没有写完) 碎碎念 我还是单身(立个flag，我要比兔佬提前脱单)，单身挺好的(真香警告.jpg)。 不忘初心，牢记使命，坚定信仰，深入学习习近平新时代中国特色社会主义思想，学习十九大精神，为中国特色社会主义事业奋斗终身，(走错片场了) 竟然胖了三斤，防微杜渐 没钱，穷 大二期间打死都不接前端的锅了 2.想法 这个学期基本上把web开发相关的流程都走了一遍，但是很多都是浅尝辄止，接下来的时间要为暑期实习做准备了 算法方面做的还是不够好，刷题要重视起来。 基础打好 3.规划 寒假把Spring那一套过一遍 把上面三本书都看完一遍，完成实验。 看《算法导论》，刷题(量肯定是要比这个学期多，先定个目标: 15道medium/month，10道hard/month ) 深入学习Docker和Kubernetes 退休。。 找个女朋友]]></content>
      <categories>
        <category>学期总结</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门总结]]></title>
    <url>%2F2018%2F12%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[这是我个人学习使用Docker的知识总结，如果想要系统的学习参照官方文档 简单理解 docker是一种容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。先来一张图 docker相对于虚拟机来说要便捷许多。 docker与虚拟机的比较 特性 docker 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB级 GB级别 性能 接近原生 若弱于原生 系统容纳量 单机支持上千个容器 一般十几个 docker的结构 用一张图来表示吧 简单地说，docker存在image，container这两种东西，要跑的是container。而container是由image产生的，而image可以通过docker build 出来，也可以从远程repository pull下来。 Docker build 首先，先要建立一个Dockerfile。Dockerfile里面写的代码可以理解为创建image的一个流程，当然实际生成一个image后面有很多看不到的过程, (以搭建一个nodejs后端服务器为例): 123456789101112FROM node: version# 首先指定镜像基础，这里是构建node环境并指定版本COPY . /app # 指定工作目录WORKDIR /app# 将当前目录拷贝到images的/app目录RUN npm install --repository=https://registry.npm.taobao.org# 安装nodeJS程序的依赖EXPOSE 8008# 开放image的3000端口CMD ["node", "server.js"]# 在container运行时执行 node server.js 创建dockerfile之后，再新建.dockerignore 文件，这里主要是排除一些不要被build的文件 1234.git node_modulesnpm-debug.log# 这里主要是排除git，和nodejs的模块，需要的模块在在build的时候 RUN npm install 会自动安装 build 1docker build -t imageName path path为build的文件目录”起点“，一般是”./“ 即当前目录 Docker Run 首先我们要跑的是container，所以可以先查看有哪些container 1docker container ls Run 12345docker container run --rm -p 8080:8008 -i -t imageName /bin/bash //--rm 表示container停止后自动删除容器文件//-i 让容器的标注输入保持打开//-t 让Docker 分配一个伪终端并绑定到容器的标准输入上//-p 表示端口映射，将docker的8008端口映射到宿主机的8080端口 Docker 命令的一些细节 退出docker 1234561. docker kill containerID //结束进程，containerId的话不需要输全的，只要前四位就行啦2. dockerstop containerName//在docker 里面1. Ctrl+D 2. exit 进入Docker 12341. docker attch [option] containerId//忘记怎么使用的可以docker attch --help 2. docker exec [options] //如:进入redis, $ docker exec containerId redis-cli Docker实现细节 贴一篇博客 CGroups Namespaces clone中使用，提供了对UTS（ UNIX Time-sharing System ）、IPC、mount、PID、network、User等的隔离机制 UTS namespace（UTS namespaces）： 用来隔离系统的 hostname 以及 NIS domain name IPC namespace（CLONE_NEWIPC），IPC有共享内存、信号量、消息队列等方法，只有在同一个Namespace下的进程才能相互通信 PID namespace（CLONE_NEWPID）：将子进程的pid在容器中变成1 Mount Namespace（CLONE_NEWNS）：建立一个独立的文件系统 User Namespace，使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534（不知道外部的，所以设置最大值）,可设置 Network Namespace（CLONE_NEWNET）： Docker镜像分层 对于Linux镜像：docker镜像在运行的时候直接使用docker宿主机器的kernel。 Docker 的一些推荐 阮一峰Docker入门教程 阮一峰Docker微服务 Docker–从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Docker</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 1234567891011121314// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值//如果该模型存在的话，就会放货这个模型 以上是我认为一个后端程序的基本结构了。有些东西一直在变化，如有问题请参照官方文档。 启动 基本的：node server.js 要知道，后端不仅仅是将程序跑起来，运维也是一个很大的问题。这里推荐使用pm2 当然，现在微服务很流行，docker也是很必要的啦！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
</search>
