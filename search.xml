<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[person_summary.md]]></title>
    <url>%2F2018%2F12%2F24%2Fperson-summary-md%2F</url>
    <content type="text"><![CDATA[web学期总结 1.回（chan)顾(hui)框架和语言and tools Javascript: nodeJs(别的不多说了，贴一张图)和express框架，微信小程序，Vue，mongodb。 Java: Java的基础部分都过了一遍，Spring这套东西还在看。 Python: 平时写算法的时候用，没有进一步的深入学习。Flask框架路由映射的实现，没事写写爬虫(写的都是些玩具。) Go: …算了吧，连官方文档都没有看完。 Docker: Docker image 的构建，Docker微服务的使用 SSH：凑合用吧，能够满足基本需求 Nginx: 基本的反向代理，负载均衡，没有深入学习。 计算机基础 《http权威指南》看到了加密部分。(貌似全忘了。。。) 《计算机网络自顶向下》，看到网络层了的BGP(Border Gateway Protocol)，这一章看的很懵X。 LeetCode算题 《深入理解计算机系统》,看到第二章节了。 《数据库系统设计与原理》，算了，不说了，绪论才看完。 算法：dp算法，分治法。红黑树二叉树(实现代码还没有写完) 碎碎念 我还是单身(立个flag，我要比兔佬提前脱单)，单身挺好的(真香警告.jpg)。 不忘初心，牢记使命，坚定信仰，深入学习习近平新时代中国特色社会主义思想，学习十九大精神，为中国特色社会主义事业奋斗终身，(走错片场了) 竟然胖了三斤，防微杜渐 没钱，穷 大二期间打死都不接前端的锅了 2.想法 这个学期基本上把web开发相关的流程都走了一遍，但是很多都是浅尝辄止，接下来的时间要为暑期实习做准备了 算法方面做的还是不够好，刷题要重视起来。 基础打好 3.规划 寒假把Spring那一套过一遍 把上面三本书都看完一遍，完成实验。 看《算法导论》，刷题(量肯定是要比这个学期多，先定个目标: 15道medium/month，10道hard/month ) 深入学习Docker和Kubernetes 退休。。 找个女朋友]]></content>
      <categories>
        <category>学期总结</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpringMvc]]></title>
    <url>%2F2018%2F12%2F16%2FJavaSpringMvc%2F</url>
    <content type="text"><![CDATA[对最近学习的JavaSpring做一个总结 概念MVC Model View Controller JavaMVCJava的Mvc一般是基于Servlet的Spring Mvc的工作原理 SpringMvc 主要由DispatcherServlet、处理器映射、控制器、视图解析器，视图组成的。 在图中很容易看出，DispatcherServlet 是SpringMvc 是核心，它负责处理Http的请求并根据servletName-servlet.xml提供的信息去寻找处理器。 找到处理器后，调用处理器，DispatcherServlet将请求提交到Controller ，Controller 处理完逻辑代码后返回ModelandView; DispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelandView指定的视图，最后视图负责把结果显示到客户端 一个简单的SpringMvc 部分文件结构(基于maven构建项目,不重要的就不贴了) 123456789101112131415161718192021web文件夹── web ├── WEB-INF │ ├── JSP │ ├── applicationContext.xml │ ├── css │ ├── html │ ├── images │ ├── log4j.properties │ ├── springmvc-servlet.xml │ └── web.xml └── index.jspsrc部分 ├── main │ ├── java │ │ ├── Controller │ │ ├── IndexController.java │ │ ├── LoginController.java │ │ │ │ │ └── resources 先看web.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--以上是一些名字空间命名--&gt; &lt;servlet&gt; &lt;!--这里是servlet实例的配置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--这里是servlet实例的配置文件位置--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。取正整数表示该Servlet容器的加载优先级--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 这是路由请求映射关系，这里指的是所有请求都由sprigmvc这个servlet容器去处理--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springmvc-servlet.xml(这是由命名规则的，servletName-servlet.xml) 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 添加了namespace还需要在schema中声明其位置 --&gt; &lt;context:component-scan base-package="Controller" /&gt; &lt;context:component-scan base-package="service" /&gt; &lt;!--这里采用基于注解的装配控制器方式--&gt; &lt;mvc:annotation-driven /&gt; &lt;!--允许所有css，html images 文件可见--&gt; &lt;!-- resource 过滤掉不需要dispatcherservlet mapping表示匹配原则--&gt; &lt;mvc:resources mapping="/css/**" location="/WEB-INF/css/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/html/**" location="WEB-INF/html/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="WEB-INF/images/"&gt;&lt;/mvc:resources&gt; &lt;!--下面注释的两行是用xml装配控制器的代码--&gt; &lt;!--&lt;bean name="/login" class="LoginController"/&gt;--&gt; &lt;!--&lt;bean name="/register" class="RegisterController"/&gt;--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; &lt;/beans&gt; controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//引入相关的包，这里包括了注释部分需要的包@Controller//分层路由处理public class IndexController &#123; @RequestMapping("/login") //@RequestMapping("/login")完成了对/login的映射，当请求为/login时交由login函数处理 public String login()&#123; return "login"; /* 这里返回 login ，由于在xml中有声明 &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; 所以实际视图解析器会去/html目录下去查找login.html文件 */ &#125; @RequestMapping("/register") public String register(HttpServletRequest request, HttpServletResponse response)&#123; // 行为参数获取请求参数 String uname = request.getParameter("uname"); String upass= request.getParameter("upass"); //code to verify //... //if not verified return "register"; //if verified //return "login";&#125; //通过@PathVariable 获取参数// @RequestMapping(value = "/register/&#123;uname&#125;/&#123;upass&#125;/",method = RequestMethod.GET)// public String register(@PathVariable String uname, @PathVariable String upass,Model model)&#123;// //code to verify// //model for jsp// return "register";// &#125; //通过@PathParam接受请求参数// @RequestMapping("/register")// public String register(@RequestParam String uname,@RequestParam String upass)&#123;// //code to verify// return "login";// &#125;// @RequestParam 和通过形式参数获取请求参数时，使用前者方式，请求参数和接收参数不一致时会返回404，而后者不会 //重定向 return "forward:/index/isLogin";// return "redirect:/index/isRegister";&#125; 小结 最近在看JavaSpring的东西，感觉Java好重，这篇就是自己回顾，感觉写的乱七八糟，关于JavaSpring的推荐去看《JavaSpring实战》 还是脚本语言写应用层后端爽，感觉Java的优势主要体现在大的项目]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMvc</tag>
        <tag>Backend</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门总结]]></title>
    <url>%2F2018%2F12%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[这是我个人学习使用Docker的知识总结，如果想要系统的学习参照官方文档 简单理解 docker是一种容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。先来一张图 docker相对于虚拟机来说要便捷许多。 docker与虚拟机的比较 特性 docker 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB级 GB级别 性能 接近原生 若弱于原生 系统容纳量 单机支持上千个容器 一般十几个 docker的结构 用一张图来表示吧 简单地说，docker存在image，container这两种东西，要跑的是container。而container是由image产生的，而image可以通过docker build 出来，也可以从远程repository pull下来。 Docker build 首先，先要建立一个Dockerfile。Dockerfile里面写的代码可以理解为创建image的一个流程，当然实际生成一个image后面有很多看不到的过程, (以搭建一个nodejs后端服务器为例): 123456789101112FROM node: version# 首先指定镜像基础，这里是构建node环境并指定版本COPY . /app # 指定工作目录WORKDIR /app# 将当前目录拷贝到images的/app目录RUN npm install --repository=https://registry.npm.taobao.org# 安装nodeJS程序的依赖EXPOSE 8008# 开放image的3000端口CMD ["node", "server.js"]# 在container运行时执行 node server.js 创建dockerfile之后，再新建.dockerignore 文件，这里主要是排除一些不要被build的文件 1234.git node_modulesnpm-debug.log# 这里主要是排除git，和nodejs的模块，需要的模块在在build的时候 RUN npm install 会自动安装 build 1docker build -t imageName path path为build的文件目录”起点“，一般是”./“ 即当前目录 Docker Run 首先我们要跑的是container，所以可以先查看有哪些container 1docker container ls Run 12345docker container run --rm -p 8080:8008 -i -t imageName /bin/bash //--rm 表示container停止后自动删除容器文件//-i 让容器的标注输入保持打开//-t 让Docker 分配一个伪终端并绑定到容器的标准输入上//-p 表示端口映射，将docker的8008端口映射到宿主机的8080端口 Docker 命令的一些细节 退出docker 1234561. docker kill containerID //结束进程，containerId的话不需要输全的，只要前四位就行啦2. dockerstop containerName//在docker 里面1. Ctrl+D 2. exit 进入Docker 1231. docker attch [option] containerId//忘记怎么使用的可以docker attch --help 2. docker exec [options] Docker 的一些推荐 阮一峰Docker入门教程 阮一峰Docker微服务 Docker–从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Docker</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 1234567891011121314// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值//如果该模型存在的话，就会放货这个模型 以上是我认为一个后端程序的基本结构了。有些东西一直在变化，如有问题请参照官方文档。 启动 基本的：node server.js 要知道，后端不仅仅是将程序跑起来，运维也是一个很大的问题。这里推荐使用pm2 当然，现在微服务很流行，docker也是很必要的啦！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Spring Jdbc学习笔记]]></title>
    <url>%2F2018%2F12%2F02%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[JavaSpring事务管理(1) 文件结构1234567.├── applicationContext.xml└── scheme ├── Dao.java ├── JdbcTest.java ├── TestDaoImpl.java ├── User.java JDBC配置省略部分代码applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;context:component-scan base-package="JDBC.scheme"&gt;&lt;/context:component-scan&gt;&lt;!-- 申明该xml配置文件“作用范围” --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/java?useSSL=false"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value=""&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置需要连接数据库信息 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建JdbcTemplate模版--&gt;&lt;/beans&gt;``` ## 创建实体类 User.java```javapublic class User &#123; //映射的事情由jdbctemplate来完成，前提是名字与数据库里面的要一一对应； private Integer id; private String name; private String sex; //toString方便查看对象属性 public String toString()&#123; return "myuser(id="+String.valueOf(id)+",name:"+name+",sex:"+sex+"date:"+"2018]"; &#125; public void setId(Integer id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setSex(String sex)&#123; this.sex = sex; &#125;&#125; JavaTemplate实例的创建TestDaoImpl.java1234567891011121314151617181920212223242526272829303132333435@Repository("testDao")//将该实例注入xml文件，交由Spring来管理，可用ApplicationContext对象的getBean("testDao")获取public class TestDaoImpl implements Dao &#123; @Autowired //使用xml文件中配置好的jdbc实例 private JdbcTemplate jdbcTemplate; @Override //对Dao的接口重写 public int update(String sql,Object[] param)&#123; return jdbcTemplate.update(sql,param); //返回更新的行数 &#125; @Override public List&lt;User&gt; query(String sql, Object[] param)&#123; //这里使用BeanPropertyRowMapper会比自己实现RowMapper要简单一些 // BeanPropertyRowMapper可以自动调用相应的setter对对象进行赋值 RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); return jdbcTemplate.query(sql,rowMapper,param); // RowMapper&lt;User&gt; userMapper = new UserMapper(); // return jdbcTemplate.query(sql,userMapper,param); &#125;&#125;//如果要用注释所用方法query,则需要自己实现一个RowMapper类class UserMapper implements RowMapper&lt;User&gt; &#123; //结果是以 行 为单位返回的 public User mapRow(ResultSet rs,int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); user.setSex(rs.getString("sex")); return user; &#125;&#125; 测试JdbcTest.java1234567891011121314151617181920212223public class JdbcTest &#123; public static void main(String[] args)&#123; ApplicationContext appcon = new ClassPathXmlApplicationContext("/JDBC/applicationContext.xml");// ApplicationContext appcom = new FileSystemXmlApplicationContext("src/JDBC/applicationContext.xml"); Dao td = (Dao) appcon.getBean("testDao"); String insertSql = "insert into user values(?,?,?,NOW())"; Object param1[]=&#123;1,"Benji","boy"&#125;; Object param2[]=&#123;2,"Lee","boy"&#125;; Object param3[]=&#123;3,"Jimmy","boy"&#125;; Object param4[]=&#123;4,"Lily","girl"&#125;; Object param5[]=&#123;5,"Morry","girl"&#125;; td.update(insertSql,param1); td.update(insertSql,param2); td.update(insertSql,param3); td.update(insertSql,param4); td.update(insertSql,param5); String selectSql = "select * from user"; List&lt;User&gt; list = td.query(selectSql,null); for(User user:list)&#123; System.out.println(user); &#125; &#125;&#125; JdbcTemplate 常用方法 update() query() …和SQL语句差不多,可以查询官方文档]]></content>
      <categories>
        <category>JavaSpring学习笔记</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Java</tag>
        <tag>Curd</tag>
        <tag>CodeLife</tag>
      </tags>
  </entry>
</search>
