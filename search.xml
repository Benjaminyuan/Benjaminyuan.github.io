<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker入门总结]]></title>
    <url>%2F2018%2F12%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[这是我个人学习使用Docker的知识总结，如果想要系统的学习参照官方文档 简单理解 docker是一种容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。先来一张图 docker相对于虚拟机来说要便捷许多。 docker与虚拟机的比较 特性 docker 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB级 GB级别 性能 接近原生 若弱于原生 系统容纳量 单机支持上千个容器 一般十几个 docker的结构 用一张图来表示吧 简单地说，docker存在image，container这两种东西，要跑的是container。而container是由image产生的，而image可以通过docker build 出来，也可以从远程repository pull下来。 Docker build 首先，先要建立一个Dockerfile。Dockerfile里面写的代码可以理解为创建image的一个流程，当然实际生成一个image后面有很多看不到的过程, (以搭建一个nodejs后端服务器为例): 123456789101112FROM node: version# 首先指定镜像基础，这里是构建node环境并指定版本COPY . /app # 指定工作目录WORKDIR /app# 将当前目录拷贝到images的/app目录RUN npm install --repository=https://registry.npm.taobao.org# 安装nodeJS程序的依赖EXPOSE 8008# 开放image的3000端口CMD ["node", "server.js"]# 在container运行时执行 node server.js 创建dockerfile之后，再新建.dockerignore 文件，这里主要是排除一些不要被build的文件 1234.git node_modulesnpm-debug.log# 这里主要是排除git，和nodejs的模块，需要的模块在在build的时候 RUN npm install 会自动安装 build 1docker build -t imageName path path为build的文件目录”起点“，一般是”./“ 即当前目录 Docker Run 首先我们要跑的是container，所以可以先查看有哪些container 1docker container ls Run 12345docker container run --rm -p 8080:8008 -i -t imageName /bin/bash //--rm 表示container停止后自动删除容器文件//-i 让容器的标注输入保持打开//-t 让Docker 分配一个伪终端并绑定到容器的标准输入上//-p 表示端口映射，将docker的8008端口映射到宿主机的8080端口 Docker 命令的一些细节 退出docker 1234561. docker kill containerID //结束进程，containerId的话不需要输全的，只要前四位就行啦2. dockerstop containerName//在docker 里面1. Ctrl+D 2. exit 进入Docker 1231. docker attch [option] containerId//忘记怎么使用的可以docker attch --help 2. docker exec [options] Docker 的一些推荐 阮一峰Docker入门教程 阮一峰Docker微服务 Docker–从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>自动化部署</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 1234567891011121314// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值//如果该模型存在的话，就会放货这个模型 以上是我认为一个后端程序的基本结构了。有些东西一直在变化，如有问题请参照官方文档。 启动 基本的：node server.js 要知道，后端不仅仅是将程序跑起来，运维也是一个很大的问题。这里推荐使用pm2 当然，现在微服务很流行，docker也是很必要的啦！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Spring Jdbc学习笔记]]></title>
    <url>%2F2018%2F12%2F02%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[JavaSpring事务管理(1) 文件结构1234567.├── applicationContext.xml└── scheme ├── Dao.java ├── JdbcTest.java ├── TestDaoImpl.java ├── User.java JDBC配置省略部分代码applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;context:component-scan base-package="JDBC.scheme"&gt;&lt;/context:component-scan&gt;&lt;!-- 申明该xml配置文件“作用范围” --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/java?useSSL=false"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value=""&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置需要连接数据库信息 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建JdbcTemplate模版--&gt;&lt;/beans&gt;``` ## 创建实体类 User.java```javapublic class User &#123; //映射的事情由jdbctemplate来完成，前提是名字与数据库里面的要一一对应； private Integer id; private String name; private String sex; //toString方便查看对象属性 public String toString()&#123; return "myuser(id="+String.valueOf(id)+",name:"+name+",sex:"+sex+"date:"+"2018]"; &#125; public void setId(Integer id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setSex(String sex)&#123; this.sex = sex; &#125;&#125; JavaTemplate实例的创建TestDaoImpl.java1234567891011121314151617181920212223242526272829303132333435@Repository("testDao")//将该实例注入xml文件，交由Spring来管理，可用ApplicationContext对象的getBean("testDao")获取public class TestDaoImpl implements Dao &#123; @Autowired //使用xml文件中配置好的jdbc实例 private JdbcTemplate jdbcTemplate; @Override //对Dao的接口重写 public int update(String sql,Object[] param)&#123; return jdbcTemplate.update(sql,param); //返回更新的行数 &#125; @Override public List&lt;User&gt; query(String sql, Object[] param)&#123; //这里使用BeanPropertyRowMapper会比自己实现RowMapper要简单一些 // BeanPropertyRowMapper可以自动调用相应的setter对对象进行赋值 RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); return jdbcTemplate.query(sql,rowMapper,param); // RowMapper&lt;User&gt; userMapper = new UserMapper(); // return jdbcTemplate.query(sql,userMapper,param); &#125;&#125;//如果要用注释所用方法query,则需要自己实现一个RowMapper类class UserMapper implements RowMapper&lt;User&gt; &#123; //结果是以 行 为单位返回的 public User mapRow(ResultSet rs,int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); user.setSex(rs.getString("sex")); return user; &#125;&#125; 测试JdbcTest.java1234567891011121314151617181920212223public class JdbcTest &#123; public static void main(String[] args)&#123; ApplicationContext appcon = new ClassPathXmlApplicationContext("/JDBC/applicationContext.xml");// ApplicationContext appcom = new FileSystemXmlApplicationContext("src/JDBC/applicationContext.xml"); Dao td = (Dao) appcon.getBean("testDao"); String insertSql = "insert into user values(?,?,?,NOW())"; Object param1[]=&#123;1,"Benji","boy"&#125;; Object param2[]=&#123;2,"Lee","boy"&#125;; Object param3[]=&#123;3,"Jimmy","boy"&#125;; Object param4[]=&#123;4,"Lily","girl"&#125;; Object param5[]=&#123;5,"Morry","girl"&#125;; td.update(insertSql,param1); td.update(insertSql,param2); td.update(insertSql,param3); td.update(insertSql,param4); td.update(insertSql,param5); String selectSql = "select * from user"; List&lt;User&gt; list = td.query(selectSql,null); for(User user:list)&#123; System.out.println(user); &#125; &#125;&#125; JdbcTemplate 常用方法 update() query() …和SQL语句差不多,可以查询官方文档]]></content>
      <categories>
        <category>JavaSpring学习笔记</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Java</tag>
        <tag>Curd</tag>
        <tag>CodeLife</tag>
      </tags>
  </entry>
</search>
