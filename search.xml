<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 12345678910111213// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Backend</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Spring Jdbc学习笔记]]></title>
    <url>%2F2018%2F12%2F02%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[JavaSpring事务管理(1) 文件结构1234567.├── applicationContext.xml└── scheme ├── Dao.java ├── JdbcTest.java ├── TestDaoImpl.java ├── User.java JDBC配置省略部分代码applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;context:component-scan base-package="JDBC.scheme"&gt;&lt;/context:component-scan&gt;&lt;!-- 申明该xml配置文件“作用范围” --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/java?useSSL=false"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value=""&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置需要连接数据库信息 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建JdbcTemplate模版--&gt;&lt;/beans&gt;``` ## 创建实体类 User.java```javapublic class User &#123; //映射的事情由jdbctemplate来完成，前提是名字与数据库里面的要一一对应； private Integer id; private String name; private String sex; //toString方便查看对象属性 public String toString()&#123; return "myuser(id="+String.valueOf(id)+",name:"+name+",sex:"+sex+"date:"+"2018]"; &#125; public void setId(Integer id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setSex(String sex)&#123; this.sex = sex; &#125;&#125; JavaTemplate实例的创建TestDaoImpl.java1234567891011121314151617181920212223242526272829303132333435@Repository("testDao")//将该实例注入xml文件，交由Spring来管理，可用ApplicationContext对象的getBean("testDao")获取public class TestDaoImpl implements Dao &#123; @Autowired //使用xml文件中配置好的jdbc实例 private JdbcTemplate jdbcTemplate; @Override //对Dao的接口重写 public int update(String sql,Object[] param)&#123; return jdbcTemplate.update(sql,param); //返回更新的行数 &#125; @Override public List&lt;User&gt; query(String sql, Object[] param)&#123; //这里使用BeanPropertyRowMapper会比自己实现RowMapper要简单一些 // BeanPropertyRowMapper可以自动调用相应的setter对对象进行赋值 RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class); return jdbcTemplate.query(sql,rowMapper,param); // RowMapper&lt;User&gt; userMapper = new UserMapper(); // return jdbcTemplate.query(sql,userMapper,param); &#125;&#125;//如果要用注释所用方法query,则需要自己实现一个RowMapper类class UserMapper implements RowMapper&lt;User&gt; &#123; //结果是以 行 为单位返回的 public User mapRow(ResultSet rs,int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); user.setSex(rs.getString("sex")); return user; &#125;&#125; 测试JdbcTest.java1234567891011121314151617181920212223public class JdbcTest &#123; public static void main(String[] args)&#123; ApplicationContext appcon = new ClassPathXmlApplicationContext("/JDBC/applicationContext.xml");// ApplicationContext appcom = new FileSystemXmlApplicationContext("src/JDBC/applicationContext.xml"); Dao td = (Dao) appcon.getBean("testDao"); String insertSql = "insert into user values(?,?,?,NOW())"; Object param1[]=&#123;1,"Benji","boy"&#125;; Object param2[]=&#123;2,"Lee","boy"&#125;; Object param3[]=&#123;3,"Jimmy","boy"&#125;; Object param4[]=&#123;4,"Lily","girl"&#125;; Object param5[]=&#123;5,"Morry","girl"&#125;; td.update(insertSql,param1); td.update(insertSql,param2); td.update(insertSql,param3); td.update(insertSql,param4); td.update(insertSql,param5); String selectSql = "select * from user"; List&lt;User&gt; list = td.query(selectSql,null); for(User user:list)&#123; System.out.println(user); &#125; &#125;&#125; JdbcTemplate 常用方法 update() query() …和SQL语句差不多,可以查询官方文档]]></content>
      <categories>
        <category>JavaSpring学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Curd</tag>
        <tag>Backend</tag>
        <tag>CodeLife</tag>
      </tags>
  </entry>
</search>
