<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux_kernel]]></title>
    <url>%2F2020%2F02%2F09%2FLinux-kernel%2F</url>
    <content type="text"><![CDATA[内核简介内核组成? 负责响应中断的中断服务程序 负责管理多个进程，分享处理器时间的调用程序 复制进程地址空间的内存管理程序 网络、进程间通讯等系统服务程序Linux内核和Unix内核的比较 所有Unix内核同宗同源，提供的API是一样的 Unix内核需要硬件提供MMU管理内存， Linux一般不需要微内核和单内核设计比较 单内核所有的服务都在同一地址空间，内核可以直接调用函数，微内核的功能被划分为多个独立的过程，每个过程被叫做服务器，所有的服务器都运行在各自的地址空间上，服务器之间的通讯需要通过消息传递（IPC）。 IPC的开销大于函数调用Linux的优点 Linux是单内核，但是Linux吸取了微内核的精华，支持模块化设计、抢占式内核、支持内核线程、动态装载内核模块 Linux和Unix的差异 Linux支持动态加载内核模块，单内核，但是可以在允许时动态的卸载和加载除部分内核代码 Linux支持对称多处理器（SMP），传统Unix并不支持 Linux内核可以抢占，Linux内核具有允许在内核运行的任务优先执行的能力， Linux内核不区分线程和其他一般的进程。对于内核来说，所有进程都一样，只不过一些共享的资源不同Linux内核版本12345// 主版本号 修订版本号// ｜ |// 2 . 6 . 26 . 1// | ｜// 从版本号 稳定版本号 进程管理进程 线程：拥有独立的程序计数器，进程栈，一组进程寄存器 内核调度对象是线程 进程是处于执行期的程序以及相关的资源的总称 线程：fork()-&gt;clone()进程描述符及任务结构 进程描述符：task_struct 任务队列：task_struct的双向链表分配进程描述符 Linux通过slab分配器分配，2.6以前，各个进程的task_struct存放在他们内核栈的尾端，（方便查找），2.6之后，slab分配器动态生成task_struck，所以只需要在栈低(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)/创建一个struct thread_info进程描述符存放 pid:唯一标识进程（int），最大值为32768（short int 短整数的最大值） current宏查找当前正在运行的进程。 x86 体系：利用计算偏移间接地查找task_struct结构（抹去低13位） 专门的寄存器存储thread_info地址进程状态 TASK_RUNNING：运行或者在任务队列中等待执行 TASK_INTERRUPTIBLE：进程正在睡眠，等待某些条件达成，或者收到信号被唤醒 TASK_UNINTERRUPTIBLE：不可以被信号唤醒 _TASK_TRACED：被其他进程追踪。 _TASK_STOPPED：进程停止执行：没有投入运行也不能投入运行设置当前进程状态 set_task_state(task,state)进程上下文 程序执行了系统调用，或触发了某个异常，它就陷入了内核空间，内核代表进程执行处于“进程上下文”中，在此上下文中current宏是有效的进程家族树 所有的进程都是PID为1的进程的后代进程创建 fork()调用：拷贝当前进程创建一个子进程。子进程和父进程的区别仅仅在于PID，PPID(父进程的PID)和某些资源和统计量（挂起的信号，没有必要别继承）写时拷贝 fork()使用copy-on-write页实现，fork()的开销主要在于复制父进程的页表以及给子进程创建唯一的PIDfork() 调用链 1\\ fork() -&gt; clone() -&gt; do_fork() -&gt; copy_process() -&gt; dup_task_struct() copy_proces() 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct（此时与当前线程无任何差别） 确保创建子进程后，分配给用户的资源没有超过限制 子进程状态设置为TASK_UNITERRUPTIBLE，保证不会投入运行 copy_flags()更新task_struct的flags成员，确保一些flag被设置或清零（代表是否拥有超级用户权限的PF_SUPERPRIV清零，表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置） 调用alloc_pid()为新进程分配一个有效的PID 根据传递给clone的参数标志不同，copy_process拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。共享的话不拷贝，不共享则拷贝。 返回一个指向子进程的指针。 回到do_fork() copy_process调用成功后，新创建的子进程被唤醒并让其投入运行vfork() 除了不拷贝父进程的页表项外，vfork()和fork()功能一致线程在Linux的实现 线程：进程间的共享资源的手段。创建线程12clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,0);//共享地址空间、文件系统资源、文件描述符、信号处理程序 内核线程 内核线程和普通线程的区别：内核线程没有独立的地址空间（指向地址空间的mm指针被设置为NULL）,内核线程只在内核空间运行，从来不到用户空间去。进程终结 终结（可以显示调用exit()）动作：释放资源，传递信号给父进程 主要工作由do_exit()完成 将task_struct中的标志成员设置为PF_EXITING 调用del_timer_sync()删除任意内核定时器，确保没有定时器在排队 BSD的进程记账功能是开启的话，调用acct_update_integrals()来输出记栈信息 exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用他们，就彻底释放它们。 sem__exit()如果进程排队等候IPC信号，它则离队 exit_files()和exit_fs()递减文件描述符，文件系统数据的引用计数，如果某个引用计数数值降为0，此时可以释放 存放task_struct的exit_code成员中的任务退出代码置为exit()提供的退出代码，方便父进程随时检索 exit_notify()向父进程发送信号，给子进程重新找养父，并把线程状态设置为EXIT_ZOMBIE 调用schedule()切换到新的进程。 处于EXIT_ZOMBIE状态的进程占用内存为内核栈，thread_info结构和stak_struct结构，唯一作用是给父进程提供信息。在父进程获取已终结的子进程信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放， wait()：挂起一个进程，直到其中的一个进程退出。（会释放内核栈和thread_info的结构所占的页，并释放task_struct所占的slab高速缓存进程调度多任务 现代操作系统对程序一般采用动态时间片计算的方式，并且引入了可配置的计算策略。（但是Linux不是）Linux的进程调度 Linux2.5：采用O(1)调度程序 Linux2.6初期：引入新的调度算法，其中最著名的是：“反转楼梯最后期限调度算法”(RSDL) Linux2.6.23内核版本中替代了O(1)调度算法，取而代之的是（完全公平调度算法）CFS 策略I/O消耗型和处理器消耗型的进程 I/O消耗型：大多时间在等待I/O请求或者提交I/O请求。 处理器消耗型：进程时间大多数用在执行代码上。进程优先级 Linux采用两种不同的优先级 nice值 range: -20到+19 nice越低优先级越高 nice是所有Unix系统中的标准化的概念，但是由于调度算法不同，运用方式不同 Mac OS X，进程的nice值代表分配给进程的时间片的绝对值，而Linux系统，nice值则代表时间片的比例。 实时优先级 默认值：0到99，越高线程优先级越高时间片 表明线程在被抢占前能够持续运行的时间。调度策略必须规定一个时间片 Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了线程，这样使得线程获得的处理器时间其实是和系统负载密切相关的。nice值作为权重调整进程所使用的处理器时间使用比。 Linux的抢占行为：当一个进程进入可运行状态时，抢占时机取决于新的可运行程序消耗多少处理器使用比。如果消耗的使用比 比当前进程小，则新进程立刻投入运行，否则推迟运行。Linux调度算法调度器类 Linux调度器使用模块的方式提供，使得不同类型的进程可以有针对性地选择调度算法。 Unix系统中的进程调度 两点：进程优先级、时间片 问题：分配绝对的时间片会引发固定的切换频率 完全公平调度(CFS)是一个针对普通进程的调度类，Linux中称为 SCHED_NORMAL CFS完全摈弃时间片而是分配给进程一个处理器使用比重 CFS理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器 周转：允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。 CFS在所有可运行的进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重，越高的nice值获得越低的处理器使用权重。CFS进程获得的时间片底线默认值为1ms（防止频繁切换） 任何线程所获得的处理器时间是他自己和其他所有可运行进程nice值的相对差值决定的Linux调度的实现时间记账 CFS使用调度器实体结构：struct sched_entity来追踪进程运行记账，struct task_struct中名为se的成员变量 虚拟实时：vruntime，进程的虚拟运行时间（进过所有可运行进程总数的标准化） 系统定时器周期性调用update_curr计算进程上次计算到当前计算的delta_exec，通过进程总数对运行时间进程加权运算，最后将权重值与运行进程的vruntime相加进程选择 核心：当要选择下一个进程时，它会挑一个具有最小vruntime的进程。 CFS通过红黑树来组织可运行的进程队列：CFS选择算法可以总结为运行rbtree中的最左边的叶子节点所代表的那个进程 删除进程发生在 进程阻塞（不可运行态）或者终止时（结束运行）调度器入口 schedule()：通常都需要和一个具体的调度类相关联（高优先级优先），调用pick_next_task()选择进程睡眠和唤醒 等待队列：等待某些时间发生的的进程简单链表，内核用wake_queue_head_t来代表等待队列 创建：DECLARE_WAITQUEUE()静态创建或init_waitqueue_head()动态创建 加入等待队列 123456789DEFINE_WAIT(wait);add_wait_queue(q,&amp;wait);while(!condition)&#123; prepare_to_wait(&amp;q,&amp;wait,TASK_INTERRUPTIBLE); if(signal_pending(current)) //处理信号 schedule();&#125;finish_wait(&amp;q,&amp;wait); 调用DECLARE_WAITQUEUE()创建一个等待队列 add_wait_queue()把自己加入队列中，该队列会在进程等待的条件满足是唤醒，时间发生时，对等待队列执行wake_up()操作 prepare_to_wait()将进程状态变为TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE 如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程（伪唤醒） 进程被唤醒的时候，它会再次检查条件是否为真，如果是则退出循环，否则再次调用schedule()并一直重复这步操作 当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己退出等待队列 唤醒 wake_up()进行，唤醒指定的等待队列上的所有进程。 调用函数try_to_wake_up()将进程设置为TASK_RUNNING状态 调用enqueue_task()将进程放入红黑树中。 如果被唤醒的进程优先级比当前正在执行的进程优先级高，还要设置need_resched标志。通常哪段代码促使等待条件达成，就要负责随后调用wake_up()函数。抢占和上下文切换 上下文切换：可执行进程切换到另外一个可执行线程。当一个进程被选出来准备投入运行时，schedule() 会调用context_switch() switch_mm()负责把虚拟内存从上一个进程映射切换到新进程中 switch_to()该函数负责从上一个进程的处理器状态切换到新进程的处理器状态（保存、恢复栈信息和寄存器信息）。 内核提供一个need_resched标志（每一个进程都包括一个标志）来表明是否需要重新执行一次调度。 当进程被抢占时，scheduler_tick()就会设置这个标志 当优先级高的进程进入可执行状态的时候，try_to_wake_up()也会设置这个标志 返回用户空间以及从中断返回的时候，内核也会检查need_resched标志，如果被设置，内核会在继续执行之前调用调度程序 用户抢占 用户抢占发生 系统返回用户空间时 从中断处理程序返回用户空间时内核抢占 只要调度是安全的，内核可以在任何时间抢占正在执行的任务 支持 为每一个进程的thread_info引入preempt_count计数器，初值为0，每当使用锁的时候数值加1，释放锁的时候数值减1，数值为0时可以抢占。 need_resched被设置，同时preempt_count为0时，调度程序就会被调用 发生时机 中断处理程序正在执行，且返回内核空间之前 内核代码再一次具有可抢占性的时候 如果内核中的任务显示调用schedule() 如果内核中的任务阻塞（同样调用schedule())实时调度策略 两种调度策略：SCHED_FIFO和SCHED_RR SCHED_FIFO 处于可以运行状态的SCHED_FIFO级进程会比任何SCHED_NORMAL级的进程都先得到调度 一旦SCHED_FIFO级进程处于可执行状态，就会一直执行（可以被高优先级抢占），同级的SCHED_FIFO进程轮流执行，直到自己受阻塞或者显式地释放处理器为止 SCHED_RR SCHED_RR与SCHED_FIFO大致相同 SCHED_RR是带时间片的SCHED_FIFO,时间片用于调度同一优先级处理器绑定 Linux提供强制的处理器绑定机制。 保存在task_strcut 的cpus_allowed位掩码，默认所有位被设置放弃处理器时间 Linux通过sched_yield()系统调用，让进程显示地将处理其时间让给其他等待执行进程系统调用内核通讯 Linux中系统调用是用户空间访问内核的唯一手段POSIX、API、C库调用关系 应用程序–&gt; C库–&gt; 内核 Unix接口设计：“提供机制而不是策略”,机制：“需要提供什么样的功能”，策略：“怎样实现这些功能”系统调用 通常通过C库中定义的函数调用来进行 系统调用出错的时候C库会把错误码写入errno全局变量，调用perror()库函数，可以把变量翻译成用户可以理解的错误字符串 getpid()系统调用 123SYSCALL_DEFINE0(getpid)&#123; return task_tgid_vnr(current);//return current-&gt;tgid&#125; SYSCALL_DEFINE0 只是一个宏，定义一个无参数的系统调用 SYSCALL_DEFINE(functionName,param_1_type,param_1,type return_param) 定义 asmlinkage：编译指令，通知编译器仅从栈中提取该函数的参数 1asmlinkage long sys_getpid(void) 命名：sys_functionName() 系统调用号 Linux中，每个系统调用被赋予一个系统调用号，一旦分配就不能再有任何变更 如果一个系统调用被删除，防止编译的代码出错 Linux有一个“未实现”系统调用sys_in_syscall()，它除了返回-ENOSYS不做任何事情，为错误的系统调用而设的。 系统调用表：sys_call_table（x86-64中，它定义于arch/i386/kernel/syscall_64.c系统调用性能 Linux系统调用比许多操作系统执行要快（很多，指谁？），上下文切换时间较短，系统调用处理程序和每个系统调用本身就很简洁系统调用处理程序 用户空间的程序无法直接执行内核代码，因此应用程序需要用某种方式通知系统，告诉内核自己需要执行一个系统调用。 策略：系统切换到内核态，代表应用程序在内核空间执行系统调用 通知内核机制：软中断 通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序实际上是系统调用处理程序。 在X86系统上预定义的软中断是中断号128,通过int $0x80指令触发该中断，该指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序–system_call()指定恰当的系统调用 陷入内核的同时需要将系统调用号传给内核 X86上，系统调用号是通过eax寄存器传递给内核的 system_call()函数 通过传递给定的系统调用号与NR_syscalls做比较来检查有效性,如果大于等于 NR_syscalls，该函数返回-ENOSYS，否则执行响应的系统调用1call *sys_call_table(,%rax,8) 参数传递 最简单的方式：将参数传入寄存器中，x86-32系统上，ebx、ecx、edx、esi和edi按照顺序存放前5个参数，需要6个或者六个以上使，用一个单独的寄存器存放指向指向这些参数的用户地址系统调用实现实现系统调用 要点：“提供机制而不是策略”参数验证 检查传入参数合法性 I/O调用：文件描述符是否有效 进程相关：进程PID是否有效 资源访问： 用户指针指向的内存属于用户空间 指针指向的内存区域在进程的地址空间里 进程不能绕过内存访问限制 定义系统调用实例1234567891011SYSCALL_DEFINE3(silly_copy,unsigned long *,src,unsigned long * dst,unsigned long len)&#123; unsigned long buf; //copy_from_user都是返回没有完成拷贝的字节 if(copy_from_user(&amp;buf,src,len))&#123; return -EFAULT; &#125; if(copy_to_user(dst,&amp;buf,len))&#123; return -EFAULT; &#125; return len;&#125; 系统调用上下文 系统在执行系统调用时处于进程上下文 current执行当前任务，即引发系统调用的那个进程绑定系统调用 Linux系统调用表 首先在系统调用表中加入一个表项，从0开始 对于所支持的各种体系结构，系统调用号都必须定义于\&lt;asm\/unistd.h>中 系统调用必须被编译成内核映像（放在kernel/下的一个相关文件中就行来了） 定义一个名为foo()的系统调用为例 加入系统调用表（entry.s)(Linux5.4中x86系统调用表位置：arch/x86/entry/syscalls/syscall_64.tbl) 添加系统调用号(Linux5.4中x86系统调用号定义位置：arch/sh/include/uapi/asm/unistd_64.h） 编写系统调用 用DEFINE\&lt;n>的宏定义（最后展开是一样的）123asmlinkage returnType funcName(type params)&#123; // code &#125; 从用户空间访问系统调用 库 系统调用宏形式,_syscalln()1#define NR_open 5 _syscall3(long,open,const char*,filename,int,flags,int,mode) 内核数据结构链表 Linux链表不是将数据结构塞入链表，而是将链表节点塞入数据结构 12345//链表结构struct list_head&#123; struct list_head *next; struct list_head *prev;&#125; 通过宏container_of()我们可以很方便地从链表指针找到父结构中包含的任何变量 123456struct fox &#123; unsigned long tail_length; unsigned long weight; bool is_fantastic; struct list_head list;&#125; Linux提供一系列操作链表API 队列映射二叉树]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jvm笔记]]></title>
    <url>%2F2020%2F02%2F08%2Fjvm%2F</url>
    <content type="text"><![CDATA[Jvm 整体思路 共有设计，私有实现，始终贯穿，不同虚拟机对于jvm的设计实现上有一定的差别 Java内存区域和内存移除异常运行时数据区域程序计数器 程序位置指示器 线程私有Java虚拟机栈 线程私有 方法执行时会创建栈帧 局部变量表:用变量槽（32位）保存8种基本数据类型&amp;&amp; 引用， 操作数栈（Java指令架构时基于栈的） 动态连接 方法出口本地方法栈 和虚拟机栈类似 区别在于是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务堆 对象实例存放的地方 可以通过-Xms,-Xmx改变大小方法区 存放虚拟机加载的类型信息，常量，静态变量，即时编译后(JIT)的代码缓存 包括运行时常量池 编译期生成的各种字面量和符号引用，类加载后会存放进方法区 Hotpot 采用本地内存来实现元空间，元空间是方法区的实现直接内存 不属于虚拟机运行时数据区 IO时分配堆外内存，可以减少一次Java堆到Native堆的拷贝HotPot虚拟机对象对象创建 new字节码指令执行过程 常量池中定位符号引用 检查符号引用对于的类是否加载，如果没有加载，这先执行类加载 分配内存（取决于垃圾收集器是否带有空间压缩整理的能力） 内存绝对规整：指针碰撞（Bump The Pointer） 不规整（已使用内存和未使用内存交错）：维护一个空闲列表 更新的原子性 CAS + 失败重试 每个线程预分配(Thread Local Allocation Buffer TLAB) 设置对象初始信息 对象头（Object Header） 执行构造函数()对象内存布局 mark word 123456// 32bit //-----//hash:25:-----------------&gt;| age:4 biased_lock:1 lock:2 (normal object)//JavaThread*: epoch:2 age:4 Biased_lock:1 lock:2 (biased object)//size:32--------------------------------------&gt;| (CMS free block)//PromotedObject*:29--------&gt;| promo_bits:3----&gt;| (CMS promoted object) 对象有效信息: 从自身定义字段+父类继承下来的字段 HotSpot分配策略 存储顺序：longs/doubles,ints,shorts,chars,bytes/booleans,oops 相同宽度的字段总是被分配在一起 在满足以上前提，父类定义的字段会出现在子类之前 对其填充 HotSpot虚拟机自动内存管理要求对象起始地址必须是8字节的整数倍对象的访问定位 主流访问方式 使用句柄：对象移动时，只改变句柄池的实例数据指针 直接指针：直接指向对象的内存位置 区别：使用句柄多一次指针定位的时间开销 HotSpot使用直接指针OutOfMemoryError异常Java堆溢出虚拟机栈和本地方法栈溢出 请求栈深度大于虚拟机允许的深度 –&gt; StackOverflow，常见：递归 当虚拟机栈内存允许动态拓展，拓展栈无法申请到足够的内存时，将抛出OutOfMemoryError异常（HotSpot不支持）方法区和运行时常量池溢出 字符串问题 String.intern()方法，JDK6中，首次遇到的字符串实例复制到永久代的字符串常量池中，返回的也是永久代里面这个字符串的引用，而JDK7 只需要将常量池里面记录一下首次出现的实例引用即可 JDK6 HotSpot中，字符串常量池在方法区（永久代），而JDK7 后，被移到类Java堆中 方法区溢出 CGLib技术直接操作字节码运行时生成大量的动态类本机直接内存溢出 Unsafe类向操作系统申请内存 问题排查：是否使用了DirectMemory 垃圾收集器和内存分配策略聚焦问题 那些内存需要回收 什么时候回收 如何回收对象存活问题引用计数算法 描述：在对象中添加一个引用计数器，每有一个地方引用它，计数器值就加1，引用失效时就减1，应用为0则无用了 简单，效率高，但是存在循环引用问题可达性分析算法 描述：通过一系列的“GC Root” 的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，如果对象不跟任何引用链相连，则被认为不再被使用。 Java技术体系里面，固定可以作为GC Roots的对象包括 虚拟机栈中引用的对象， 方法区中的静态属性引用，如类的引用类型静态变量 方法区中常量引用的对象，譬如字符串常量池里引用的对象 本地方法栈中的JNI引用的对象 Java虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻的异常等，还有系统的类加载器 所有被同步锁持有的对象 Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等 除以上固定的，还有其他对象“临时性”地加入，共同构成完整的GCRoots集合引用引用 应用的概念扩冲 强引用：Object obj = new Object(); 软引用：有用非必须，在将要发生内存溢出异常前，会把这些对象列进回收范围进行第二次回收，如果这次回收没有足够的内存，才会发生内存异常，JDK 1.2版本之后提供列SoftReference类来实现软引用 弱引用：非必须对象，关联的对象只能生存到下一次垃圾收集发生为止。JDK 1.2后使用WeakReference类来实现弱引用 虚引用：不会对对象的生存时间构成影响 JDK 1.2后，提供PhantomReference类来实现虚引用To die to 死亡 –&gt; finalize() F-Queue队列由虚拟机自动建立的，低调度优先级的Finalizer线程去执行finalize()方法（不保证能够执行完成） 一个对象的finalize()只能执行一次回收方法区 允许回收条件 该类的所有实例都已经被回收，Java堆中不存在该类及其任何派生子类的实例 该类的类加载器被回收，一般很难达成 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射获得该类的方法 允许回收不一定要回收垃圾回收算法分代收集理论 假说 弱分代假说：绝大多数对象都是朝生夕灭 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 跨代引用假说：跨代引用相对与同代引用来说仅占及其少数 –&gt; 引出记忆集概念标记-清除算法 描述：标记所有要清除的算法，标记完成后统一回收所有被标记的对象 缺点： 执行效率不高，需要扫描大量对象，执行大量标记和清除动作。 内存空间的碎片化问题，标记、清除之后产生的大量不连续的内存碎片。标记-复制算法 描述：将可用内存分为大小相等的两块，每次只使用其中的一块。每一块用完了就将还存活的对象赋值到另外一块（HotSpot是8:1:1） 商用Java虚拟机大多采用这种算法收集新生代。 分配担保机制标记-整理 描述：存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。 缺点： 移动存活对象需要STW 移动和不移动，that’s a question: 不移动影响内存分配，移动影响吞吐量 HotSpot算法细节实现根节点枚举 根节点枚举必须在一个保障一致性的快照中进行（所有的收集器在根节点枚举时都得STW） 改进： 准确式垃圾收集：用户线程停下来后，不需要逐个检查引用位置，虚拟机存储存放对象引用的地方 HotSpot解决方案：使用一组OopMap的数据结构，类加载动作完成时，记录对象内制定偏移位置的数据类型。无需一个不漏地从方法区等GC Roots开始查找安全点 OopMap的问题：让OopMap内容变化的指令很多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间。HotSpot只在特定的地方记录OopMap，这些位置被称为 安全点 所有线程跑到最近的安全点才能暂停，开始垃圾收集 安全点位置选取：以“是否具有让程序长时间执行的特征” 为标准进行选定的，如方法调用，循环跳转，异常跳转等功能指令才会产生安全点 中断有两种方式 抢先式中断：垃圾回收时，系统首先把所有的用户线程全部中断，如果有线程没有中断在安全点上，则恢复执行，直到跑到安全点上。 主动式中断：当垃圾回收需要中断线程时，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程中会不停地主动轮询这个标志，一旦发现中断标志为真就自己在最近的安全点上主动中断挂起。安全区域 定义：一段代码片段之中，引用关系不会发生变化，因此在这个区域任何地方开始垃圾回收都是安全的。 行为：当线程会标识进入安全区域，当这段时间发生垃圾回收时，虚拟机不会管已声明在安全区域的线程，当线程离开安全区时，需要检查虚拟机是否已经完成了跟节点枚举，只有完成跟节点枚举才能继续运行记忆集与卡集 定义：记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构 记忆集精度 字长精度 对象精度 卡精度：“卡表” 卡表的简单形式可以是一个字节数组，HotSpot实现也是这样 123//HotSpot使用的卡页大小为2的9次幂，512字节//只要卡页里面有跨代指针就标识为1，称为变脏，将其加入GC Roots中一并扫描CARD_TABLE[this_address &gt;&gt; 9] =0; 写屏障（区分“内存屏障”） 虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，类似与AOP技术，在赋值前的操作叫做写前屏障，在赋值后的操作叫做写后屏障。 HotSpot 通过写屏障技术维护卡表状态，在写屏障中添加更新卡表操作。 卡表更新的缓存问题：改成只有没有变脏的才能变脏，HotSpot：-XX:+UseCondCardMark,开启 并发的可达性分析 引出问题：GCRoots相比Java堆的对象是极少数的，停顿时间较短，但是遍历对象图时间和Java堆容量成正比，需要削减遍历时间 三色标记法 白色：对象未被垃圾收集器访问过。开始时-&gt;都为白色，结束时白色-&gt;不可达 黑色：标示被垃圾收集器访问过，且其所有的引用都已经扫描过了 灰色：被访问过，但是对象上至少还有一个引用没有被扫描过 并发工作是可能存在的问题： 赋值器插入了一条或多条黑色对象到白色对象的新引用 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用 解决方案 增量更新：记录被新插入指向白色对象引用的黑色对象，并发扫描结束后以这些记录过的黑色对象为根，重新扫描一次。(CMS) 原始快照：当灰色对象要删除指向白色对象的引用时，记录要被删除的引用记录，在扫描结束之后，与这些记录过的引用关系中的灰色对象为根重新扫描一次。(G1,Shenandoah) 相比增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗。经典垃圾回收器Serial收集器 描述：单线程工作的收集器，一个线程处理垃圾收集工作，同时必须暂停其他工作线程。 新生代：标记-复制，老年代：标志-整理 。 HotSpot虚拟机客户端模式下默认新生代收集器 优点：内存消耗最小，单核处理器或处理器核心数较少的环境来说，serial收集器没有线程交互的开销。在系统分配资源较少时，还不错。ParNew收集器 描述：ParNew收集器实质上是Serial收集器的多线程并行版本 大多数运行在服务端模式下的HotSpot虚拟机中首选的新生代收集器 默认开启收集线程数和处理器逻辑核心数量相同Parallel Scavenge收集器 描述：基于标记-复制算法实现的新生代收集器，关注点是达到一个可控制的吞吐量。 $$吞吐量 = {运行用户代码时间}/{(运行用户代码时间+运行垃圾收集时间)}$$ 策略：控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis，设置吞吐量大小-XX:GCTimeRatio,垃圾停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。Serial Old收集器 描述：单线程Serial收集器的老年代版本，使用标记-清除 用途： Parallel Scavenge收集器搭配使用 作为CMS收集器发生Concurrent Mode Failure 时的后备预案Parallel Old收集器 描述：Parallel Old 是Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现CMS（Concurrent Mark Sweep）收集器 描述：一种以获取最短回收停顿时间为目标，基于标记-清除算法的收集器。 过程 初始标记（CMS initial mark）：标记GCRoots能直接关联到的对象，（STW） 并发标记（CMS concurrent mark）：从GCRoots能直接关联的对象开始遍历整个对象图的过程。 重新标记（CMS remark ）：修正并发标记的期间，标记变动的对象标记（STW） 并发清除（CMS concurrent sweep）：清理标记阶段死亡的对象 关联：增量更新 特点 并发标记和并发清理阶段，用户线程还在运行，标记过程结束后的产生的垃圾无法在本次GC清理，存在“浮动垃圾” 基于上一特点，CMS收集器存在启动阀值 如果在CMS垃圾回收过程中，预留内存无法满足程序分配内存的需要（Concurrent Mode Failure），会启动后备预案：冻结用户线程的执行，临时使用Serial Old 收集器来重新进行老年代的垃圾收集。Garbage First收集器 描述：面向服务端应用的垃圾收集器,JDK9服务端模式默认回收器 过程 初始标记：标记GCRoots能直接关联到的对象，STW 并发标记：从GCRoots开始对堆中的对象进行可达性分析。 最终标记：用于处理并发阶段结束后遗留的少量SATB记录，STW 筛选回收：根据各个Region的回收价值和成本进行排序，将需要回收Region的存活对象复制到空的Region,STW 特点： G1收集器面向整个Java堆，用来垃圾数量做衡量标准，使回收收益最大，Mixed GC模式 把连续的Java堆划分为多个大小相等的独立区域（region），每一region都可以成为Eden,Survivor,或者老年代空间，Region是最小回收单元，-XX:G1HeapRegionSize设定大小[1MB,32MB] 2^N次 G1还有一类Humongous区域用于存放大对象，一般当作老年代的一部分看待，判定标准：大于Region容量一半的对象 G1收集器会跟踪各个Region里的垃圾堆积的“价值”，在后台维护一个优先级列表，优先收集价值最大的Region。 从G1开始，最先进的垃圾收集器设计导向都不约而同地变为追求能够应付应用内存的分配速率。 存在问题和解决方案 跨Region引用问题：记忆集 哈希表：Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这样的结构内存消耗比较大，每一个Region都要有一份卡表，至少要消耗相当于Java堆容量10%至20%的额外内存来位置收集器工作， 并发标记时收集线程和用户线程冲突问题 G1为每一个Region设计两个名为TAMS（Top at Mark Start）的指针，把Region划分出来用于分配新对象，G1默认这个地址上的对象是隐式标记的。 如何建立停顿等待预测模型 -XX:MaxGCPauseMillis 制定垃圾收集之前的期望值。 衰减均值为理论基础：普通平均值更容易收新数据的影响，但是衰减平均值更加准确地代表“最近的”平均状态 低延迟垃圾收集器 衡量垃圾回收器的三项重要指标，“不可能三角” 内存占用 吞吐量 延迟Shenandoah 描述：和G1类似，基于Region的堆内存布局，同样有Humongous Region，支持和用户线程并发的整理算法，摈弃了G1中消耗大量内存的记忆集，改名为“连接矩阵”的全局数据来维护跨Region的引用关系（类似于图里面的邻接矩阵）。 过程 初始标记：标记和GCRoots直接关联的对象 并发标记：遍历对象图 最终标记：处理甚于的SATB 并发清理：清理没有一个存活对象的region 并发回收：复制存活对象到未使用的Region 初始引用更新：复制对象结束后，还需要把堆中的所有指向旧对象的引用修正到复制后的新地址，引用更新。初始引用更新只是一个线程集合点，确保回收阶段的收集器线程都完成了任务 并发引用更新：真正开始的引用更新。 最终引用更新：修正存在于GCRoots的引用 并发清理：最后并发清理回收集的Region 转发指针 实现对象移动和用户程序并发的解决方案 方案-1 通常是在被移动对象原有的内存上设置保护陷阱，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，由异常处理器中的代码逻辑把访问转发到复制后的新对象上。 会导致用户态频繁切换到核心态，代价大 Brooks（大佬）提出的新方案 在原有的对象布局结构的最前面同一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己 两次访问内存，存在开销，同时要保证对对象的写入只能发生在新的对象中（CAS实现）。ZGCZGC的内存布局 基于Region的堆内存布局 ZGC的Region具有动态性–动态创建和销毁 ZGC的Region可以分为大、中、小三类容量 小型Region：size固定：2MB,用于放置小于256KB的小对象 中型Region：size固定：32MB,用于放置大于等于256KB但小于4MB的对象 大型Region：容量不固定&gt;=4MB，可以动态变化，但是必须是2NMB,用于大于等于4MB的对象，不会被重分配染色指针技术 将标记信息记在引用对象的指针上 原理 在64位系统中理论可以访问的内存高达16EB但是处于成本和性能的考虑， 在AMD64架构中只支持到52位的地址总线和48位的虚拟地址空间 64位的Linux则分别支持47位的进程虚拟地址空间和46的物理地址空间，64位Window甚至只支持44位的物理地址空间 ZGC提取46位中的高4位来存储4个标志信息，意味着ZGC管理内存不能超过2^42B12345/*|-------Unused(18bit)------| Finalizable| Remapped | Marked1 |-Marked0-|-----------Object Address(42bit)-----------|*/ 染色指针优势 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用调（“自愈”特性） 减少内存屏障的使用 染色指针可以作为可拓展的存储结构来记录更多的对象标记 定义内存的可能性 X86实现：Linux平台上，ZGC使用多重映射，不同地址段映射到同一个物理内存空间。 ZGC过程 并发标记：可达性分析，更新染色指针中的Marked0、Marked 1标志位 并发预备重分配：根据特定的查询条件统计本次需要清理哪些Region，将这些Region组成重分配集，每次回收会扫描所有的Region，ZGC的分配集只是决定了里面的存活对象会被重新复制到其他的Region中 并发重分配：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录旧对象到新对象的转向关系，访问时预置的的内存屏障会被截获，同时修正其值 并发重映射：修正整个堆中指向重分配集中旧对象的所有引用，可自愈，不急迫 类文件结构无关性的基石 Class文件Class文件结构 Class文件以8个字节为基础单位的二进制流。 数据类型： “无符号数”：属于基本的数据类型，以u1、u2、u4、u8 “表”：所有表都以“_info”结尾，整个Class文件本质上也可以视作一张表魔数和Class文件的版本访问标志 u2:代表访问标志，和这个标志用于标志一些类或者接口层次的访问信息，包括Class是类还是接口，是否定义为public,abstract,final。使用位运算表示。类索引、父类索引和接口索引集合 u2:类索引 u2:夫类索引 u2:接口长度，u2:接口索引字段表集合 u2:access_flag，访问标志 u2:name_index，字段的简单名称：没有类型和参数修饰，全限定名：包名+类名，/ 分割 u2:descriptor_index，类型描述，如：java.lang.String[][] –&gt; ‘[[Ljava/lang/String;’ u2:attributes_count attribute_info:方法表集合 基本和字段表一致，访问标志符多了几个 属性表集合 u2: attribute_name_index,如code，exceptions等的 u4:attribute_length,1 u1:info,attribute_length 字节码指令简介字节码与数据类型 i(int),l(long),s(short),b(byte),c(char),f(float),d(double),a(reference)加载和存储指令 jvm虚拟机基于操作数栈的 \&lt;type>load_\:iload,iload_1,n为操作数栈顶的第n个操作数 \&lt;type>store_\:istore,istore_1运算指令 operator:add,sub,mul,div,rem(求余),neg(取反)，ish[l|r]移位指令, \&lt;type>operator类型转化指令 \&lt;type>2\ 小范围到大范围是安全的 浮点值转化为整数类型T: 如果浮点值是NaN，那转换结果就是int或者long类型对象创建与访问指令 创建类实例的指令：new 创建数组的指令：newarray,anewarray,multianewarray 访问类字段：getfield、putfiled、getstatic、putstatic 加载数组元素加载到操作数栈的指令,操作数栈的值存储到数组元素中\&lt;type>a(operator)，ballad、caload、saload、bastore 取数组长度：arraylength 检查类实例类型的指令：instanceof、checkcast操作数栈管理指令 操作数栈的栈顶一个或两个元素出栈：pop、pop2 复制操作数栈的栈顶一个或两个元素并且重新入栈：dup_x1、dup2_x2 互换栈顶两个元素：swap控制转移指令 条件分支：ifeq,iflt 符合条件分支 无条件分支：goto、goto_w、jsr、jsr_w、ret方法调用 invokevirtual指令：调用对象的实例方法 invokeinterface指令：调用接口方法，搜索一个实现了这个接口方法的对象 invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有化方法和夫类方法 invokestatic指令：调用类的静态方法 invokedynamic：运行时动态解析出调用点限定符所引用的方法异常处理指令 athrow同步指令 方法内部指令同步和方法级同步：使用管程(monitor，monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区)来实现。 方法级同步：虚拟机可以通过方法常量池中的ACC_SYNCHRONIZED访问标志，当方法调用时将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程。 synchronized：monitorenter，monitorexit。虚拟机类加载机制类加载时机 过程：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载 初始化时机：对一个类型进行主动引用触发初始化。 遇到new、getstatic、putstatic、invokestatic，如果类型没有被初始化，先触发初始化，对于静态字段，只有直接定义的类才会初始化。 遇到new实例化对象 读取或设置一个静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候 调用静态方法 初始化类时，同时初始化未初始化的夫类。 虚拟机启动时，用户需要指定一个执行的主类，先要初始化这个类。 接口实现类初始化时，要先初始化接口类加载过程加载 虚拟机工作 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化方法区运行时的数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口 加载阶段可以通过自定义的类加载器控制获取字节流方式 重写一个类的类加载器的findClass()或loadClass()方法 对于数组类本身不通过类加载器创建，它是由Java虚拟机在内存中直接动态构造出来的。数组类的元素类型还是要靠类加载器，数组类创建规则： 如果数组的组件类型是引用类型，递归加载组件类型 数组的组件类型不是引用类型（如：int），Java虚拟机会把数组C标记为与引导类加载器关联 数组类的可访问性与它的组件类型一致。 加载结束后，加载的字节流按照虚拟机所设定的格式存储在方法区，同时生成java.lang.Class类的对象，这个对象将作为程序访问方法区中的数据类型的外部接口 验证 文件格式验证： 验证点 是否魔数开头 主次版本是否是Java虚拟机所接受的 常量池的常量中是否有不被支持的常量类型（tag标志） Class文件中的各个部分及文件本身是否有被删除或者附加的信息 目的 保证输入的字节流能正确解析并存储于方法区内 元数据验证 验证点 是否有父类 是否继承了不被允许继承的类 是否是抽象类，是否实现了其父类或者接口之中要求实现的所有方法 类中的字段、方法是否与父类产生矛盾（覆盖类父类的final字段，不符合规则的方法重载 目的 对类的元数据进行语义校验，（个人理解：是否违背了Java面向对象的规则） 字节码验证 验证点 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作 跳转指令的合法性 类型转化的有效性（不合法如：父亲对象赋值给子类数据类型） 优化 减少数据流分析和控制流分析的消耗，将更多的校验挪到编译器里进行，新增StackMapTable StackMapTable:描述类方法体所有的基本块（按照控制流拆分代码块）开始时本地变量表和操作数栈的状态，使得字节码验证的类型推导变成了类型检查 符号引用验证 验证点 符号引用通过字符串描述的全限定名是否能够找到对应的类 指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段 符号引用中的类、字段、方法的可访问性是否可被当前类访问 目的 主要保证解析行为能够正常执行准备 为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（“0”值，被final修饰的话，会在这一阶段赋值为指定的值） 概念上分配在方法区，但是JDK8后类变量会随着Class对象一起存放在Java堆中。解析 将Java虚拟机将常量内的符号引用替换为直接引用(定义：直接引用是可以直接指向目标指针、相对偏移量或者一个间接定位到目标的句柄) invokedynamic指令，符号引用多次解析不能保证是同一个实体 例子 类和接口的解析：对一个类D，将一个符号引用 N 解析为一个类或接口C的直接引用。 如果C不是一个数组类型，将符号引用N的全限定名递给D的类加载器去加载这个类C。 如果C是数组类型，并且数组类型为对象，则按照第一点的规则加载数组元素类型，然后由虚拟机生成一个代表数组维度和元素的数组对象 以上两点没有异常后检查D对C的访问权限 字段解析 解析字段表中的CONSTANT_Class_info符号引用，设所属的类或者接口为C 对C进行后续字段搜索 C包含了简单名称和字段描述符与目的字段相匹配的字段，则返回这个字段的直接引用，查找结束 如果没有，则向上查找（实现的接口和继承的类中查找，如果接口和类都有同一字段的话会冲突） 方法解析 和字段解析类似 接口方法解析 方法解析类似初始化 执行类构造器\&lt;clinit>()方法 \&lt;clinit>()编译器自动收集类中的所有类变量的赋值动作和静态语句中的语句合并生成。 收集顺序由定义顺序决定，静态语句块只能访问到静态语句块之前的变量 \&lt;clinit>()方法与类的构造函数不同，他不需要显示调用父类构造器，Java虚拟机会保证子类的\&lt;clinit>()方法执行前，父类的方法已经执行完毕。 如果类没有静态语句块，也没有对变量的赋值操作，\()方法不会生成 接口与类不同的是，执行接口的\&lt;clinit>()方法不需要先执行父接口的\&lt;clinit>()方法，只有使用了父定义的变量，父接口才会被初始化 \&lt;clinit>()方法是线程安全的类加载器类与类加载器 比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义，否则两个类来源于同一Class文件，被同一个Java虚拟机加载，只要他们的类加载器不同，那这两个类就必定不相等。双亲委派模型 Java虚拟机两种类加载器：启动类加载器(C++实现)，其他类加载器(Java语言实现) 系统提供的类加载器 启动类加载器：加载\&lt;JAVA_HOME>\lib或者被-Xbootclasspath参数指定的路径中存放的类库 拓展类加载器：加载\&lt;JAVA_HOME>\lib\ext目录中的或者被java.ext.dirs系统变量所指定的类库. 应用程序加载器：加载用户类路径上所有的类库，开发者可以直接在代码中使用这个类加载器 双亲委派模式 类加载器收到一个类加载的请求时，他首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此只有父类的加载器无法完成加载请求（他的搜索范围中没有找到所需要的类），子类才会去加载。 优点：保证Java的类和他的类加载器一起具备了带有优先级的层次，防止Java标准库中的类被用户定义的类覆盖模块下的类加载器： 维持三层加载器和双亲委派模式的架构 当平台及父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到归属，则优先委派给负责那个模块的加载器加载虚拟机字节码执行引擎概述 执行 解释执行：通过解释器执行 编译执行：编译生成本地代码执行运行时栈帧结构局部变量表 存放方法参数和方法内部定义的局部变量，Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量 变量槽：可以存放32位的数据 0号索引变量槽默认是用于传递方法对象实例的引用的 变量槽可以复用 局部变量没有赋初值不能使用操作数栈 概念上，两个不同的栈帧为不同的两个虚拟机栈的元素，完全独立，实现上会将下面栈帧的部分操作数栈和上面栈帧的部分局部变量表重叠在一起动态链接 指向运行时常量池中栈帧所属方法的引用。 符号引用一部分会在类加载阶段或者第一个使用的时候就被转化为直接引用，这被称为静态解析，另一部分将在每一次运行期间都转化为直接引用，这部分为动态连接。方法返回地址 方法执行后两种推出方法 执行引擎遇到任意方法返回的字节码指令 方法执行的过程中产生异常，本地方法的异常表中没有搜索到匹配的异常处理器，会导致方法推出。 方法退出等同于把当前栈帧出栈，因此退出可能执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧中的操作数栈中，调整PC计数器。方法调用解析 “非虚方法”：类加载的解析阶段，将一部分符号引用转化为直接引用，前提：方法在程序真正运行之前就有一个可以确定的调用版本，并且这个方法的调用在运行期是不可变的。invokestatic,invokespecial。 “虚方法”：分派 静态分派 静态类型：定义的字面类型，重载是通过静态类型作为判定依据，重载时如果没有找到准确的函数时，会自动类型转化，安全转型最优先。 动态类型：变量的实际类型 动态分派 方法调用通过动态分配： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 校验调用C类型的方法相关参数，访问权限是否相符合 否则从下向上依次对C的各个父类搜索和验证 Java只有虚方法存在，字段永远不可能是虚的，如果子类有父类一致的字段，子类会覆盖父类字段，但是内存同时存在 单分派与多分派 宗量 方法的接收者 方法的参数 Java语言属于动态分配属于单分派类型（方法接受者在）前端编译概述 编译器类型 前端编译器：.java文件转变成 .class 文件，Javac 即时编译器：运行期间把字节码转变成本地机器码，HotSpot虚拟机的C1，C2编译器，Graal编译器 提前编译器：直接把程序编译成于目标机器指令相关的二进制代码Javac编译器编译过程 一个准备过程，3个处理过程 准备过程：初始化插入式注解处理器 解析于填充符号表过程，包括： 语法、语法分析。将源代码的字节流转变为标记集合，构造出抽象语法树 填充符号表。产生符号地址和符号信息 插入式注解处理器的注解处理 分析与字节码生成过程 标注检查：对语法的静态信息进行检查 数据流控制分析：对程序动态运行过程进行检查 解语法糖： 将简化代码编写的语法糖还原为原有的形式 字节码生成：将前面各个步骤所生成的信息转化成字节码Java语法糖泛型 Java的泛型：类型擦除式泛型–只在程序源码中（历史包袱问题） C#的泛型：具现代化泛型 类型擦除 裸类型：类型泛化实例的共同父类型 无法支持原始类型数据自动装箱、拆箱与遍历循环 包装类在不遇到算术运算的情况下不会自动装箱后端编译与优化即时编译器解释器和编译器编译对象与触发条件 热点代码： 被多次调用的方法 被多次执行的循环体 编译对象：整个方法体。 热点探测 基于采样的热点探测：虚拟机会周期性的地检查各个线程的调用栈顶。 基于计数器的热点探测：虚拟机为每一个方法（甚至是代码块）建立计数器，统计方法的执行次数（HotSpot采用） HosSpot的热点计数 两种计数器：方法调用计数器、回边计数器 方法调用计数器：客户端模式是1500次，服务端是10000次 执行机制 存在即时编译的版本时，优先使用编译后的本地代码来执行。 如果不存在被即时编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器和回边计数器之和是否超过方法调用计数器的阀值，一旦超过阀值的话，将会向即时编译器提交一个该方法的代码编译请求 热度衰减：方法调用计数器统计的是一个频率，如果一段时间内其值仍然没有超过阀值，那么调用计数器就会被减少一半（这段时间被称为此方法统计的半衰期），热度衰减 回边计数器：统计方法循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边”。目的：触发栈上的替换编译 回边计数器：执行机制与方法调用计数器差不多，但是没有计数衰减的过程编译过程 标志的编译请求：编译动作在后台的编译线程中进行 过程： 平台独立的前端将字节码构造成一种高级中间的代码表示（HIR,与目标机器指令无关），优化：方法内联，常量传播会在字节码构造成HIR之前完成 平台相关的后端从HIR中产生低级中间代码表示，优化：空值检查，范围检查消除等。 平台相关的后端使用线性扫描算法，产生机器码Java的内存模型与线程Java的内存模型 主内存和工作内存 每个线程都有自己的工作内存，线程私有 -&gt; 线程间通信问题 happens before原则 程序次序规则 管程锁定规则 volatile变量规则 线程启动规则 ….volatile使用 volatile字段的作用 保证变量对所有线程的可见性，不能保证运算的正确性，保证及时写回 禁止指令重排序，内存屏障作用，重排序不能越过内存屏障。 volatile读的内存语义 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 volatile重排序的限制 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 JMM内存屏障插入策略。 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 变量值不一致的原因 处理器不直接和内存通讯，而是先将系统内存的数据读到内部缓存（L1, L2 或者其他）后进行操作。 可见性的实现 被修饰的变量在编译成汇编代码会多一条Lock指令，将缓存的数据写回内存。 对于其他线程来说，每个处理器通过总线嗅探技术来判断缓存数据的有效性 Java对象头 对象头 长度 内容 说明 32/64 bit MarkWord 存储对象的hashCode或者锁信息等 32/64 bit Class Metadata Address 存储对象类型数据的指针 32/32 bit Array length 数组的长度(普通对象没有这一项) Mark Word Java与线程线程实现 共享进程资源，轻量级进程 内核线程1:1 用户线程：1:NJava线程 1:1线程模型，直接映射到操作系统原生线程来实现Java线程调度 协同 or 抢占状态转化 New Runnable Waiting Blocked TerminatedJava与协程内核线程的局限 微服务的兴起，缩短了留给每个服务的响应时间 对于Java的线程模型而言：当请求本身执行时间短，但是数量变得多的时候，线程切换的开销会很大协程 内核线程的调度成本主要来自于用户态与核心态之间的状态切换，状态切换开销主要来自响应中断，保护和恢复执行现场的成本。 有栈协程 实现完整地做调用栈的保护、恢复工作。 无栈协程 await、async、yield关键字 有限状态机 协程 轻量 需要在应用层面实现的内容特别多 线程安全和锁优化线程安全 多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。线程安全实现方法 互斥同步 临界区，互斥量，信号量 Java实现管程： synchronized monitorenter monitorexit 机制：monitorenter指令时，首先去尝试获取对象的锁。获取后把锁计数的值增加一，执行monitorexit会将锁计数器减一，为零则释放。synchronized的实现 具体表现 对于普通的同步方法，锁为实例对象 对于静态同步方法，锁为当前对象的Class对象 对于同步方法块，锁是synchronized配置的对象重入锁ReentrantLock 等待可中断，等待线程可以选择放弃，改为处理其他事情 公平锁：按申请时间顺序来获得 锁定多个条件非阻塞同步 互斥同步：线程阻塞和唤醒性能消耗，属于阻塞同步 cmpxchg指令，CAS无同步方案 ThreadLocal: 每个Thread对象中都有一个ThreadLocalMap对象，ThreadLocal变量就是访问入口锁优化自旋锁与自适应自旋 自旋等待本身虽然避免了线程切换的开销，但是它要是占用处理器时间的，自旋时间过长会浪费系统资源 自适应自旋锁消除 通过逃逸分析，如果判断到一段代码中在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的。锁粗化 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围拓展到整个操作序列的外部 轻量级锁123456789|----------|----------------32bit-----------------------------------||--锁状态--|-----25 bit------|---4bit---|-----1bit----|----2bit-----||----------|--23bit--|-2bit--|----------|---偏向模式--|----标志位---||--未锁定--|----对象哈希码---|-分代年龄-|------0------|-----01------||轻量级锁定|---------指向调用栈中锁记录的指针---------|-----00------||重量级锁定|------------指向重量级锁的指针------------|-----10------||--GC标记--|------------------------------------------|-----11------||--可偏向--|-线程ID-_|-Epoch-|-分代年龄-|------1------|-----01------| 工作机制 代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志为 00），虚拟机在当前栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的MarkWord的拷贝 然后虚拟机使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果更新成功了，即代表线程拥有了这个对象的锁，并且对象Mark Word的锁标志变为“00” 如果CAS失败，说明至少有一个线程和当前线程竞争获取该对象的锁，检查对象的MarkWord是否指向当前的栈帧，如果当前线程已经拥有锁了，直接进入同步代码块 如果出现两条以上线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁，锁标志的状态值变为 “10” 此时MarkWord存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。偏向锁 锁会偏向第一个获得它的线程，如果接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要在进行同步。 工作机制 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志设置为“01”,把偏向模式设置成 “1”，同时使用CAS把获取到的这个锁的线程的ID记录在Mark Word中 一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上结束，如果对象处于被锁定，则变为轻量级锁，没有则变为未锁定 hashCode问题：对象头中存储的对象头保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生变化，当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，他的偏向状态被立即撤销，并且会膨胀为重量级锁，在重量级锁ObjectMonitor类里有字段可以记录非加锁状态下的MarkWord。]]></content>
      <categories>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关知识笔记]]></title>
    <url>%2F2020%2F02%2F07%2Fdb%2F</url>
    <content type="text"><![CDATA[DataBase DataBase索引的一篇文章ACID 数据库事务四大的特性 原子性(Atomicity) 一致性(Consistency) 独立性(Isolation) 持久性(Durability)索引的类型 哈希索引 B_tree Full-text索引主键和唯一索引的区别 主键是一种约束，唯一索引是一种索引 主键唯一标识一列，索引用于优化查找索引的优点 加快了数据检索的速度，减少查询时间索引的缺点 创建索引需要耗费时间 索引需要占据物理空间 mysql事务级别 read uncommitted –&gt;脏读 read commited –&gt;不可重复读，防脏读，存在幻读 repeatable read,用户当前会话可以重复读，就是每次读取的结果都相同，不管其他事务有没有提交 serializable 串行化join 博客mysql引擎 MyISAM较高的插入，查询速度，担不支持事务，B+tree作为索引结构，索引文件仅仅保存地址 InnoDB,支持事务，行锁定和外键。数据文件本身就是索引文件 Memory储存引擎，内存 ArchiveBTree和B+Tree]]></content>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS]]></title>
    <url>%2F2020%2F01%2F01%2FOS%2F</url>
    <content type="text"><![CDATA[4 进程及进程管理4.1 进程 简单地说：进程是计算机系统有限资源地基本单位，在不支持线程的处理机上是调度的基本单位(否则是线程) 进程的状态变化 运行 就绪 等待 状态变迁图: 进程的控制 功能 进程控制 进程调度 进程间的同步协调 进程创建(操作原语) 过程 形成进程控制块PCB，填充进程标识符，进程优先级(PCB块并不是创建时才生成，系统会维持一个PCB池，空闲时PCB进程标识符存放 ‘-1’) UNIX 或Linux系统中，父进程创建子进程时，该子进程继承父进程占用的系统资源，以及除进程内部系统标示符以外的其他特性 UNIX和Linux系统创建进程及应用实例(调用fork系统调用) 分配PCB 为子进程分配一个唯一的PID(进程标识号) 拷贝父进程数据段(不会有多线程线程修改父进程的变量的危险操作)和堆栈段数据到新的主存区，正文段(代码段)引用计数+1(即共享代码段) 增加与进程相关联的文件表和索引节点表的引用数，即子进程可以使用父进程打开的文件 子进程返回0,父进程返回子进程进程号(PID)进程和线程具体使用 github仓库进程撤销 归还PCB -&gt; PCB资源池，占用资源 -&gt; 父进程 转进调度程序进程等待 CPU现场保留至PCB现场保护区 PCB插入到等待队列进程唤醒 被唤醒，转为就绪态 PCB插入就绪队列 4.4 进程之间的约束关系 互斥 -&gt; 存在临界区 同步 -&gt; 进程执行有顺序限制 4.5 同步机构 操作系统提供的同步机构 锁 信号灯(信号量) 和P,V操作 锁 可以把它想像成现实生活中的锁，机制是差不多的。 信号灯 一组确定的二元组(s,q) P操作，以P(s)为例 s减1 如果结果 &gt;= 0 ,则进程继续执行 小于0，线程被封锁，并将它(前面提到过，这里插入的是进程的PCB)插入到该信号灯的等待队列中，然后进入调度程序 V操作，以V(s)为例 s值加1 如果结果大于0，进程继续执行 如果结果小于或者等于零，则从该信号灯的等待队列中移除一个进程，解除它的等待状态，然后返回本进程继续执行 V操作不会使当前线程状态变化 4.6线程互斥和同步的实现 总的来说，常见的就那么几种，直接举几个用信号灯实现的例子 简单互斥1234567891011121314151617181920// 伪代码// 这里定义cobegin 和coend之间的程序是同时执行的//main()&#123; int mutex = 1 ; cobegin p_a(); p_b(); coend &#125;p_a()&#123; p(mutex) // do something v(mutex)&#125;p_b()&#123; p(mutex) // do something v(mutex)&#125; 简单的先后123456789101112131415161718192021222324 // 伪代码，一个看病的例子，先看病，再化验，最后诊断 main()&#123; int s1 = 0; int s2 = 0; cobegin labora(); diagnosis(); coend &#125;labora()&#123; while(化验工作未完成)&#123; p(s1); 化验工作; v(s2); &#125;&#125;diagnosis()&#123; while(看病工作未完成)&#123; 看病; v(s1); p(s2); 诊断 &#125;&#125; 多级先后关系 实现思路和简单先后的思想差不多，如果要让线程-1在另外一个线程-2后面执行，只需要控制信号灯的值在线程-1 执行完之前都小于等于0即可 生成者消费者问题123456789101112131415161718192021222324252627282930313233// 一个有界缓冲区 多个消费者度，多个生产者写问题// _ _ _ _ _ _ _ _ // 读 &lt;-- | | | | | | | | &lt;-- 写// &lt;-- |_|_|_|_|_|_|_| &lt;-- main()&#123; int full = 0; //缓冲区可读的缓冲块数目 int empty = n; // 缓冲区可写的缓冲区数目 int mutex = 1; // 同时只能有一个线程能够写/读缓冲区 cobegin p1();p2();p3();pk(); c1();c2();c3();ck(); coend&#125;producer()&#123; while(/*生产未完成*/)&#123; //生产一个产品; p(empty); p(mutex); // 写一个缓冲块 v(mutex); v(full); &#125;&#125;consumer()&#123; while(/*还要继续消费*/)&#123; p(full); p(mutex); // 读一个缓冲块; v(mutex); v(empty); &#125;&#125; 4.7进程通信进程通信的几种方式 消息缓冲通信 在进程的主存空间设置一个接收区，然后用接收原语(原语可以理解为原子性操作，即操作不可分割)接收消息。 信箱通信 用户空间信箱 系统空间信箱4.8线程 概念提出 -&gt; 为了进一步提高系统的并行处理能力 线程描述 线程是进程的一条执行路径 私有堆栈和处理机环境(PC,CPU运行时间,寄存器) 共享父进程的主存(想一下和子进程的区别？) 任务调度的基本单位(一般地，进程是系统资源分配的基本单位，线程是系统调度的基本单位)内核线程和用户线程 内核线程由操作系统支持，运行在内核空间 用户线程是在内核的支持下，在用户层通过线程库实现(即用户态线程和内核线程不一定是1:1，也有可能是多对一)。Linux下进程和进程管理 Linux下面，线程被视为一个与其他进程共享某些资源的特殊进程 PCB -&gt; task_struct 进程状态基本和上述一致，但是等待状态有TASK_INTERUPTIBLE和TASK_UNINTERUPTIBLE，即是和否可以被中断改变其等待状态 Linux查看当前系统启动时间 top w uptime fg,bg,ctrl+z,jobs fg +作业号，将后台程序调度到前台 bg 与fg相反 ctrl+z将程序挂起 jobs查看正在运行的任务tar -c:compress，打包 -x:extract, 提取 -g:gzip，提取或压缩 -j:bzip2，提取或压缩 -v:verbose(详细)，显示指令执行过程 -f:指定提取或压缩后的文件名以及位置软链接和硬链接 硬链接和文件本身的inode号是一样的 相当于软链接是保存链一个绝对路径 Linux查看进程命令 processes Statistic ps -aux 查看系统所有的进程 ps -IA 查看所有系统的数据 pa axif 连通部分进程树状态 pstree top 进程间通讯 信号量 信号 管道 socket 消息队列 共享内存(最快) 文件锁进程间的比较 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 一些细节操作系统中 heap 和 stack 的区别 栈:由操作系统自动分配释放，存放函数的参数值，局部变量的值等。 堆:一般由程序员分配释放，若程序员不释放，程序结束后OS自动回收 栈使用的是一级缓存，堆使用的是二级缓存。]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jpa-model]]></title>
    <url>%2F2019%2F04%2F13%2FJpa-model%2F</url>
    <content type="text"><![CDATA[记录Java persistence常用注射 基础@Table name : 表名 uniqueConstraints: uniqueConstraints={@UniqueConstraint(columnNames = {“columnName”,”columnNameTwo”})}, 该参数表示不可重复的列名,注意和@Column(unique=true的区别 @Id 标名为主键 一般配合@GeneratedValue()使用 @GeneratedValue strategy 增长方法 TABLE SEQUENCE IDNETITY AUTO]]></content>
      <categories>
        <category>Sring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F04%2F11%2Fredis%2F</url>
    <content type="text"><![CDATA[1读《redis in action》笔记 redis事务事务型流水线关键指令 MULTI:声明事务 WATCH: 在事务过程中观察指定键值 EXEC:执行事务 DISCARD: 在WATCH后执行，取消WATCH和清空已经进入事务队列的命令 非事务型流水线 1conn.pipeline(False) 当命令的执行结果不影响另外一个命令输入时，可以不使用MULTI和EXEC执行事务 减少了应用程序和redis之间的通讯次数,可以提升redis性能 redis 性能测试 123redis-benchmark -c 1 -q# -c client 只选定一个client进行测试# -q简化输出 性能问题 单个客户端达到redis-bench 的50%-60% 的性能 不使用流水线的预期 性能达到25%-30% 对于每个指令都使用了新的连接构建应用程序组件自动补全简单自动补全 维护一个列表 在push联系人之前先删除该联系人，将其放在最前面 减枝利用有序集合的特性 利用有序集合的特性来减少排序的开销 12345678127.0.0.1:6379&gt; zrange complete 0 -11) "abc"2) "abc`"3) "abcd"4) "abce"5) "abcz"6) "abc&#123;"7) "c" 通过讲每个元素的分值设置为0，则通过ASCII编码排序 其他的语言原理是一样的构建分布式锁 简易锁 1234567891011121314import timeimport uuiddef acquire_lock(conn,lockname,acquire_timeout= 10): identifier = str(uuid.uuid4()) end = time.time()+acquire_lock while time.time()&lt;end: if conn.setnx('lock:'+lockname,identifier): return identifier time.sleep(0.01) return False''' 问题 1.当前锁失效后会有很多线程去请求锁，会出现多个线程获取锁的情况 2.锁的持有者崩溃后不会自动释放''' 带超时的锁 123456789101112131415161718import uuidimport mathimport time def acquire_lock_with_timeout(conn,lockname,acquire_time = 10,lock_timeout=10):identifier = str(uuid.uuid4())lockname ='lock:'+ locknamelock_timeout = int(math.ceil(lock_timeout))end = time.time()+acquire_timewhile time.time()&lt;end: if conn.setnx(lockname,identifier): conn.expire(lockname,lock_timeout) return identifier elif not conn.ttl(lockname): #防止持有锁的线程崩溃 conn.expire(lockname,lock_timeout) time.sleep(0.001)return False 锁的几个关注点 锁的持有者 锁持有者崩溃 锁的持有者超时计数信号量]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithms]]></title>
    <url>%2F2019%2F03%2F18%2Falgorithms%2F</url>
    <content type="text"><![CDATA[​ 复习算法，还没有看完，先总结一波（算法怎么看得完QAQ 函数增长 上界函数$$ 0 \leq f(n) \leq cg(n)$$$$ f(n) = O(g(n))$$ 下界函数$$ cg(n) \leq f(n) $$$$ f(n) = \Omega(g(n)) $$ 渐进紧确界函数 $$ c_{1}|g(n)| \leq |f(n)| \leq c_{2}|g(n)| $$ $$ 即f(n) = \Theta(g(n)) $$ 时间复杂度 多项式时间：可用多项式函数对计算时间界限的算法$$ \Omicron(1) &lt; \Omicron(logn)&lt;\Omicron(nlogn)&lt; \Omicron(n^{2})&lt;\Omicron(n^{3})$$ 指数时间：计算时间用指数函数界限的算法$$ \Omicron(2^{n}) &lt; \Omicron(n!) &lt; \Omicron(n^{n})$$ 分治法基本思想 将原本的问题分为几个规模较小的，但类似的原问题的子问题，递归地求解这些子问题，再合并。 分解，解决，合并例子 归并排序 $$ T(n) = 2T(n/2) + cn = \Omicron(nlogn) $$ 最近点对 小于等于三个元素时，比较得出最小的点对 大于等于三时，先二分，然后再划定最小区间，在区间内更新最小值 $$ T(n) = 2T(n/2) + nlog^2n $$ 最大子数组问题 交叉的情况：从中间向两边扩散 不交叉，递归求解 $$ T(n) = \Theta(nlgn)$$ 矩阵求递归式 代换法 看递归式猜测解 代入用数学归纳法证明 $$ 如：T(n) = 2T([n/2])+n \ 猜测其解为\Omicron(nlogn) \ 代入 \ T(n) \leq 2(c[n/2]log([n/2])) + n \ \leq cnlog(n/2) +n \ = cnlogn -cnlog2 +n \ = cnlogn -(c-1)n $$ 递归树法 画出递归树，求节点，总代价即为节点的代价和 主方法 $$ T(n) = aT(n/b)+f(n)\ 如果 \epsilon &gt; 0 f(n) = \Omicron(n^{log_{b}a-\epsilon}) 则T(n)=\Theta(n^{log_{b}a})\ 若 f(n) = \Theta(n^{log_{b}a}) 则T(n) = \Theta(n^{log_{b}a}logn)\ 若 \epsilon &gt; 0 有 f(n) = \Omega(n^{log_{b}a}logn),同时 af(n/b) \leq cf(n),则T(n) = \Theta(f(n))$$ 排序 冒泡排序 这个应该是最简单的了，直接贴代码好了 插入排序 类似于抽牌排序的过程 归并排序 借用二分的思想，当分成只有一个元素的片段时就已经是排好序了 合并就类似于链表的合并，但是需要额外开辟空间 堆排序 buildTree，从右边数第一个叶子结点的父节点开始建树， 123456789101112131415161718for(int i=nums.length/2-1;i&gt;=0;i--)&#123; heapify(i); &#125;public void maxHeapify(int index)&#123; int left = 2*index +1; int right = 2*index+2; int max = index; if(left&lt;this.heapSize&amp;&amp; num[left]&gt;num[max])&#123; max = left; &#125; if(right&lt;this.heapSize&amp;&amp; num[right]&gt; num[max])&#123; max = right; &#125; if(max!=i)&#123; swap(max,i) maxHeapify(max) &#125;&#125; ​ 建堆完毕后，取出最大值后重新建堆即可 123456789public void sort()&#123; maxTreeBuild(); for(int i = num.length-1;i&gt;=0;i++)&#123; this.heapSize-- swap(i,0); maxHeapify(0); &#125;&#125; 概率分析中位数和顺序统计概念*第i个顺序统计量是该集合中第i小的元素 中位数 odd: i= (n+1)/2 oven: ave([(n+1)/2]+[(n+1)/2+1])选择第k小元素 排序 选择 quicksort_partition函数 步步紧逼最大值和最小值 遍历即可 中位数问题 一维的中位数问题 带权中位数问题 动态规划例子 切钢条$$ p[n]_{0 \leq i \leq n} = p[i]+p[n-i]$$ 矩阵链相乘 长度从 2 到n逐渐变大$$ f(x)= \left{\begin{aligned} 0 &amp;&amp; i==j \\ min_{i \leq k &lt; j}\{m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j}\} \end{aligned} \right.$$ 最优二叉搜索树 区间递增 $$ e[i,i-1] = q_{i-1}\ \omega[i,i-1] = q_{i-1}$$ $$ e[i,r-1] + e[r+1,j] + \omega[i,j] $$]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReviewQuestion]]></title>
    <url>%2F2019%2F02%2F28%2FJavaReviewQuestion%2F</url>
    <content type="text"><![CDATA[一些常见的Java面试问题 什么是基于注解的切面实现 使用注解的方式实现面向切面编程(AOP),可以在某个方法执行或者执行后插入一些代码什么是 对象/关系 映射集成模块 对象关系映射(Object Relational Mapping)即:ORM。 将面向对象程序中的对象持久化到关系数据库中。Java反射机制 Java反射机制是在运行状态中，对于任意一个实体类，都能够获得类的所有属性和方法 对于对象，可以调用它的任意方法和属性。 NetworkBS和CS的联系和区别 C/S:Client/Server,一般用于小范围的网络环境 B/S:Brower/Server，建立在广域网的基础上Cookie 和 Session的区别 Cookie是服务器在本地机器存储的小段文本并随每段请求发送至同一个服务器。 Session是一种服务器端的机制，服务器使用的一种类似于散列表的结构，当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id),保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险 JWT可以替代session，cookie的传统认证方式fail-fast 与 fail-safe 机制有什么区别 Collection类在遍历时，被修改的时候会出现（单线程和多线程都可能出现）CurrentModificationException fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException GET和POST的区别 GET是向服务器获取资源，只能通过Url的queryString来限制 而POST是将参数放在request body里 GET会退是无害的，POST会从新提交请求 GET只支持url编码，POST支持多种编码方式 Get只接受ASCII字符，POST没有限制 GET有长度限制 开源中国社区的一篇文章 [http://www.oschina.net]interface和abstract类的区别 抽象类和接口都不能够被实例化，但可以定义抽象类和接口类型的应用 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类 法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 interface abstract类 implement实现接口 extends 继承类 不能定义构造器 可以有构造器 方法全部都是抽象方法 可以有抽象方法和具体方法 定义的成员变量实际上都是常量 可以定义成员变量 成员全是public 成员可以是private，默认，protected，public IOC的优点是什么 降低计算机代码之间的耦合度。 资源集中管理，实现资源的可配置和易管理IO 和 NIO的区别，NIO优点 IO是面向流的，而NIO是面对缓冲区的。 cnblog的一篇文章什么是竞态条件，死锁？ 举个例子说明。 单两个线程竞争同一个资源时，如果对资源的访问顺序敏感，就称为存在竞态条件。 导致竞态条件发生的代码区称作临界区。在临界区中使用适当的同步就可以避免竞态条件。临界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现 如:代码中对一个类变量进行add操作就可能出现问题。(+不是一个原子性的操作) 死锁:两个线程都等待对方释放相应的对象锁MVC的各个部分都有那些技术来实现?如何实现? M：hibernate/mybatis/ibatis C：severlet/struts/spring action V：jsp/FreeMarker/tails/taglib/EL/VelocityRPC 通信和 RMI 区别 博客 WEB容器 又是一篇好文章servlet的生命周期 init():只被调用一次，servlet创建的时候被调用 service(): 处理来自客户端的请求 destroy():用来关闭数据库，停止后台线程等清理活动。 Java正则表达式 import java.util.regex.*; 正则表达式 什么是懒加载（Lazy Loading） 即延迟加载 减少网络压力 伪递归 在函数执行的最后执行自身，将得到的结果交个子函数就行了，自身计算已经完成; Java不支持自动优化尾递归 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection IOC是一种编程设计原则，减少代码之间的耦合度，借助第三方实现依赖的注入。 IOC是思想，依赖注入是设计模式 Java内存和JVM模型 转载自Hollis finalize关键字 finalize()方法: 在垃圾收集器将对象从内存中清楚出去之前做必要的清理工作(只有在该对象没有被引用时调用，且只执行一次 finalize()时Object对象的方法，但是没有实现，可以Override; volatile 可见性，但不具备原子性，适用于读操作远大于写操作 volatile修饰的变量被修改时所有使用到此变量的线程都立即能够看到变化。 内存屏蔽，防止指令重排 transient 只能修饰成员变量！！！ 用户自定义的类变量，需要实现serilizable接口才能被transient修饰 被transient修饰的变量不能被序列化 equal和‘==’区别 如果对象是从超类Object继承的equal方法时，两者完全等效。 要比较内容需要自己重写equal内容 Java switch 语句可以用的类型 byte，char, short,int以及他们的包装类 Long, float,double,boolean以及他们的包装类时不可以的。 枚举类型可以用于switch,但是Java5.0（1.5）版本以上 a = a + b 与 a += b 的区别？ a = a+b,不会进行类型转化，为了避免出错需要显式类型转换 a+=b会进行转化。 SpringjavaSpring bean的管理方式 Singleton :每个容器只有一个bean实例 prototype :为每一个bean请求提供一个实例 request : 为每个请求创建一个实例 session :为每个session global-sessionSpring注解的方式 基于xml Java配置类 注解Spring的生命周期 实例化 填充属性 调用BeanNameAware的setBeanName()方法 调用BeanFactoryAware的setBeanFactory() 调用ApplicationContextAware的setApplicationContext()方法 BeanProcessor的预初始化方法 调用InitializingBean的afterPropertiesSet() 调用自定义的初始化方法 调用BeanPostProcessor的初始化方法 调用DisposableBean的destroy()方法 调用自定义的销毁方法 进程和线程的区别 进程是操作系统资源分配的基本单位， 而线程是任务调度和执行的基本单位 进程有独立的代码和数据空间，线程没有，线程切换开销小锁锁的种类美团技术团队synchronized锁 互斥锁: 一次只允许一个线程进入被锁住的代码块 作用对象：方法块，代码块 内置锁/监视器锁，Java每一个对象都有一个内置锁，synchronized使用的是对象内置锁来锁定代码块 可见行，原子性 monitorenter, monitorexit 修饰静态变量获得的是类锁，其他是对象锁，对象锁和类锁是不冲突的 可重入: 锁的持有者是“线程” 释放: 不会出现死锁，自动释放锁，或者异常时会自动释放 乐观锁&amp;&amp;悲观锁 乐观锁：在使用数据时候不会添加锁 CAS(Java Autmtic 类) 悲观锁: 在使用数据时不管怎么样先加锁数据库连接池##网络协议 jdbc连接代码1234567891011121314151617String url="jdbc:mysql://localhost:3306/dbname?useSSL=false";String user="root";String password="password";String Driver="com.mysql.jdbc.dirver";try&#123; Class.forName(Driver); Connection conn = DriveManager.getConnecttion(url,user,paswword); Statement st = conn.createStatement(); ResultSet rs = st.excuteQuery(sql); //sql为sql的字符串形式 String sql = "UPDATE EMPLOYEES SET SALARY = ? WHERE ID = ? " PrepareStatement psmt = conn.PrepareStatement(sql); psmt.setInt(index,value); psmt.setString(); psmt.excute();&#125; hashcode 默认为内存地址 在需要hashcode时，要重写equals和hashcode方法 受检查异常(unchecked Exception),和运行异常(RunTimeException) (蓝色的为runtimeException) 反射 *public Method[] getDeclaredMethods()**返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。 public Method[] getMethods()返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法 数值计算 没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。 如: byte运算会转化成int; static关键字 被static修饰的变量或者方法不需要使用对象去访问，是属于类的，只要类被加载，就可以通过类名访问，是实例所共享的。 static方法不能访问类的非static变量（非static变量,没有实例对象的话实际上是没有被初始化的） static不会影响访问权限 抽象类 static方法不能被重写，如果子类 抽象类和接口抽象类 抽象类提供了继承的概念，它的出发点就是为了继承 接口是特殊的抽象类 抽象方法必须由子类来重写(即:声明了abstract的方法在抽象类中没有{ })，子类中不能有和父亲类相同的抽象方法 Abstract 和final，private不共戴天 子类必须重写父类所有的抽象方法 接口 比抽象类更加抽象。 默认为public 必须重写所有方法;]]></content>
      <categories>
        <category>JavaForJob</category>
      </categories>
      <tags>
        <tag>JavaReview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[network]]></title>
    <url>%2F2019%2F02%2F27%2Fnetwork%2F</url>
    <content type="text"><![CDATA[常见问题ping ICMP(internet Control Message Protocol)http和https的区别 http = http+ssl http端口80，https端口443 http为明文传输 https过程：* 客户端请求公钥，同时验证公钥 * 验证成功，客户端通过公钥加密客户端的生成的随机值，通过这个随机值进行加密解密 https会是页面加载时间延长50%，增加10%～20%的耗电TCP 三次握手目的：信息对等和防止超时; 四次握手目的 TCP连接断开过程：1、客户端TCP模块在收到应用程序的通知后，发送FIN，seq=x。2、服务器收到FIN报文段，发送ACK，确认号=x+1，并且通知应用程序客户端关闭了连接。客户端收到ACK报文段。3、服务器端的应用程序通知TCP关闭连接，服务器端TCP发送FIN+ACK，seq=y，确认号=x+1（这里ACK只是一般性的捎带ACK，TCP总是这样，以增强健壮性，反正也不费力气，从原理上说，对连接断开不是必须的）。4、客户端收到FIN+ACK报文段后，发送ACK，确认号y+1。服务器收到ACK报文段后，连接断开。 第二步是不能省略的 因为，第二步中，服务器端通知应用程序并获得反馈信息可能需要可观的时间，这可能涉及人机交互操作，也可能服务器应用层暂时还不想关闭连接。第二步结束后，服务器还可以继续通过这条连接发送数据给客户端，客户端已经不能发送数据了，但是仍然可以回复ACK。第二步中服务器立即发送确认是为了防止客户端重传FIN报文。CDN原理 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 IP地址类型 IP: 网络ID+主机ID A类地址 一个字节网络ID+3字节主机地址构成 网络地址最高位为 0 range: 1.0.0.0–126.0.0.0 B类地址 2个网络IP地址+2个主机地址 网络地址最高位为 10（即:128的二进制10000000) range:128.0.0.0–191.255,255,255 C类地址 3byte网络地址+1byte主机地址 最高位 110 range: 192.0.0.0–223.255.255.255 D类地址 广播地址保留地址 A类保留地址10.0.0.0–10.255.255.255 B类保留地址172.16.0.0–172.31.255.255 C类保留地址192.168.0.0–192.168.255.255广播地址 主机位置1 如果有子网隐码如：/17,则后17置为1;线材 双绞线Max:100m 同轴电缆:1000mepoll、poll、selectI/O模型 转发博客 IO方式 同步IO和异步IO的区别就在于：数据访问的时候进程是否阻塞 阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回I/O多路复用 内核发现进程指定的一个或多个I/O条件满足时，就通知进程。 select是POSIX定义的，epoll是Linux所特有select 特点 单个进程大概的文件描述符有限 需要轮询fd数组poll 特点 链表存储，监听的文件描述符没有限制 需要轮询epoll 特点 epoll使用一个文件描述符管理多个描述符 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目 IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数关于Reactor和PProactor模式 知乎问题 两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler 不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(read/write)]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpringUsingAnnotation.md]]></title>
    <url>%2F2019%2F01%2F21%2FJavaSpringUsingAnnotation%2F</url>
    <content type="text"><![CDATA[JavaSpringUsingAnnotation 长篇大论之前​ 最近觉得用JavaSpring的xml配置WebApplication的不方便，于是尝试用UsingNoXML的方式去写了一个简单的SpringMVC RESTful 程序。（其实近几年来，Spring也在向NoXML的方向靠拢，SpringBoot可以说是极大地解放了生产力） 工具即生产力​ Idea是世界上最好的IDE(没有之一,不接受反驳)，建议使用Idea的Springinitializr去构建项目，可以省去很多不必要的烦恼。(这个项目并不是用Springinitiallizr建立的，所以踩了很多坑QAQ) 依赖1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;Benji&lt;/groupId&gt; &lt;artifactId&gt;SpringMvcUsingAnnotation&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!-- mongodb是最主要的坑，版本依赖以Spring-4.2.0 为分界线，不然会有冲突，Spring4.2以上建议至少使用spring-data-mongodb-1.9以上的版本--&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;1.10.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/project&gt; ps:Spring版本为4.3.18 config文件结构1234567891011121314151617181920212223242526272829303132333435.├── SpringMvcUsingAnnotation.iml├── lib├── out├── pom.xml├── src├── target└── websrc文件结构:├── main│ ├── java│ │ ├── Benji│ │ │ ├── Controllers│ │ │ │ ├── HomeHandler.java│ │ │ │ ├── RestfulController.java│ │ │ │ └── WebConfig.java│ │ │ ├── Dao│ │ │ │ └── Moviedb.java│ │ │ ├── config│ │ │ │ ├── MongoConfig.java│ │ │ │ ├── Mongodb.java│ │ │ │ ├── RootConfig.java│ │ │ │ └── WebAppInitializer.java│ │ │ ├── filter│ │ │ ├── po│ │ │ │ ├── Movie.java│ │ │ │ └── MovieCollection.java│ │ │ └── web│ │ └── mongodbConfig.properties│ └── resources└── test └── java └── Benji └── MongoTest.java //这里仅供参考 src/configWebAppInitializer.java12345678910111213141516171819package Benji.config;import Benji.Controllers.WebConfig;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;//完整的配置类public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings()&#123; //映射到DispatchServlet “/” return new String[]&#123;"/"&#125;; &#125; @Override protected Class&lt;?&gt;[] getRootConfigClasses()&#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses()&#123; return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125;&#125; AbstractAnnotatationConfigDispathcherServletInitializer 容器会在CLASSPATH中查找实现了javax.servlet.ServletContainerInitializer接口的类并用来配置Servlet容器,在Spring中这个由Spring自身实现:SpringServletContainerInitializer类，而这个类又会查找WebApplicationInitializer的类，并且用它来配置Servlet容器，而AbstractAnnotationConfigDispatcherServletInitializer实现了WebApplicationInitializer，所以实现了AbstractAnnotationConfigDispatcherServletInitializer 就能完成配置 AbstractAnnotationConfigDispatcherServletInitializer类需要重写的三个函数 getServletMapping() 分配映射关系 getRootConfigClasses() getServletConfigClasses() 配置DispatcheServlet的相关配置，和XML配置中的Serve letName-servlet.xml中的东西作用相同，如：设计静态资源的管理，视图处理方式 123456789101112131415161718192021222324252627package Benji.Controllers;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration@EnableWebMvc@ComponentScan("Benji.Controllers")public class WebConfig extends WebMvcConfigurerAdapter&#123; @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("WEB-INF/Views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125;&#125;//以上Override的函数的作用，可以参见spring官方文档 如果要配置多个DispatcheServlet,参见stackoverflow 基于Java的配置可以从不同的层次去写，配置类还可以直接继承WebApplicationInitializer等类去配置 编写Controller 传统的Spring-MVCController 123456789101112131415package Benji.Controllers;import static org.springframework.web.bind.annotation.RequestMethod.*;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//import static org.springframework.web.bind.annotation.RequestMethod.GET;@Controller@RequestMapping(value="/")public class HomeHandler &#123; @RequestMapping(method=GET) public String home()&#123; return "index"; &#125;&#125; RESTful的Controller编写 12345678910111213141516171819202122232425262728293031323334package Benji.RESTfulAPI;import Benji.Dao.Moviedb;import Benji.po.Movie;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController //等价于 @Controller + @Responsebodypublic class RestfulController &#123; @Autowired Moviedb moviedb; @GetMapping("/&#123;UserName&#125;") public ResponseEntity&lt;List&lt;Movie&gt;&gt; getByUser(@PathVariable("UserName") String UserName)&#123; List&lt;Movie&gt; movieList = moviedb.findByProvider(UserName); if(movieList.size() == 0)&#123; return new ResponseEntity("provider:"+UserName+"not exit ", HttpStatus.NOT_FOUND ); &#125; /* ResponseEntity会在提供了Converter的条件下将POJO对象转化为对应的数据模式,RESTRful一般采用JSON作为数据格式，故在maven中引入 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt;即可完成自动转化 */ return new ResponseEntity(movieList, HttpStatus.OK); &#125;&#125; 数据库连接 这里用的是Spring-Mongo-data的包 数据库连接配置 1234567891011121314151617181920212223242526272829package Benji.config;import com.mongodb.Mongo;import com.mongodb.MongoClient;import com.mongodb.MongoCredential;import com.mongodb.ServerAddress;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.data.mongodb.config.AbstractMongoConfiguration;import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;import org.springframework.core.env.Environment;import java.net.UnknownHostException;import java.util.Arrays;//import sun.tools.java.Environment;@PropertySource(value = "classpath:mongodbConfig.properties",ignoreResourceNotFound = true)@Configuration@EnableMongoRepositories("Benji.Dao")public class MongoConfig extends AbstractMongoConfiguration &#123; // @Autowired// private Environment env; @Override protected String getDatabaseName() &#123; return "Movie"; &#125; public Mongo mongo() throws Exception &#123; return new MongoClient(new ServerAddress("localhost",21707)); &#125;&#125; Collection连接 1234567891011121314151617181920212223242526272829303132333435package Benji.po;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.util.Collection;import java.util.List;@Document(collection = "Movie")public class MovieCollection &#123; @Id private String id; private String provider; private List&lt;Movie&gt; Movies; public String getId()&#123; return this.id; &#125; public String getProvider()&#123; return this.provider; &#125; public void setId(String id)&#123; this.id=id ; &#125; public void setProvider(String provider)&#123; this.provider = provider; &#125; public List&lt;Movie&gt; getMovies()&#123; return this.Movies; &#125; public void setMovies(List&lt;Movie&gt; Movies)&#123; this.Movies = Movies; &#125;&#125; 定义文档对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package Benji.po;import org.springframework.data.annotation.Id;public class Movie &#123; @Id private int Id; private String name; private String size; private String publishtime; private String provider; public void setName(String name)&#123; this.name=name; &#125; public void setSize(String size)&#123; this.size =size; &#125; public void setPublishtime(String PublishedTime)&#123; this.publishtime = PublishedTime; &#125; public void setProvider(String Provider)&#123; this.provider = Provider; &#125; public String getName()&#123; return name; &#125; public String getSize()&#123; return size; &#125; public String getPublishtime()&#123; return publishtime; &#125; public String getProvider()&#123; return provider; &#125; public void setId(int Id)&#123; this.Id = Id; &#125; public Movie(int Id,String name,String size, String publishtime,String provider)&#123; this.name = name; this.Id = Id; this.publishtime = publishtime; this.provider = provider; this.size = size; &#125; public Movie()&#123; &#125; @Override public String toString()&#123; return String.format("Id:%d,Name:%s,Size:%s,Publishtime:%s,Provider:%s",Id,name,size,publishtime,provider); &#125;&#125; 以上就是SpringMvc RESTful服务的基本构成了，再设置一个服务层将CRUD和Controller分开的话，逻辑就会更加清晰些]]></content>
      <categories>
        <category>JavaSpring</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>CodeLife</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[person_summary.md]]></title>
    <url>%2F2018%2F12%2F24%2Fperson-summary-md%2F</url>
    <content type="text"><![CDATA[web学期总结 1.回（chan)顾(hui)框架和语言and tools Javascript: nodeJs(别的不多说了，贴一张图)和express框架，微信小程序，Vue，mongodb。 Java: Java的基础部分都过了一遍，Spring这套东西还在看。 Python: 平时写算法的时候用，没有进一步的深入学习。Flask框架路由映射的实现，没事写写爬虫(写的都是些玩具。) Go: …算了吧，连官方文档都没有看完。 Docker: Docker image 的构建，Docker微服务的使用 SSH：凑合用吧，能够满足基本需求 Nginx: 基本的反向代理，负载均衡，没有深入学习。 计算机基础 《http权威指南》看到了加密部分。(貌似全忘了。。。) 《计算机网络自顶向下》，看到网络层了的BGP(Border Gateway Protocol)，这一章看的很懵X。 LeetCode算题 《深入理解计算机系统》,看到第二章节了。 《数据库系统设计与原理》，算了，不说了，绪论才看完。 算法：dp算法，分治法。红黑树二叉树(实现代码还没有写完) 碎碎念 我还是单身(立个flag，我要比兔佬提前脱单)，单身挺好的(真香警告.jpg)。 不忘初心，牢记使命，坚定信仰，深入学习习近平新时代中国特色社会主义思想，学习十九大精神，为中国特色社会主义事业奋斗终身，(走错片场了) 竟然胖了三斤，防微杜渐 没钱，穷 大二期间打死都不接前端的锅了 2.想法 这个学期基本上把web开发相关的流程都走了一遍，但是很多都是浅尝辄止，接下来的时间要为暑期实习做准备了 算法方面做的还是不够好，刷题要重视起来。 基础打好 3.规划 寒假把Spring那一套过一遍 把上面三本书都看完一遍，完成实验。 看《算法导论》，刷题(量肯定是要比这个学期多，先定个目标: 15道medium/month，10道hard/month ) 深入学习Docker和Kubernetes 退休。。 找个女朋友]]></content>
      <categories>
        <category>学期总结</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpringMvc]]></title>
    <url>%2F2018%2F12%2F16%2FJavaSpringMvc%2F</url>
    <content type="text"><![CDATA[对最近学习的JavaSpring做一个总结 概念MVC Model View Controller JavaMVCJava的Mvc一般是基于Servlet的Spring Mvc的工作原理 SpringMvc 主要由DispatcherServlet、处理器映射、控制器、视图解析器，视图组成的。 在图中很容易看出，DispatcherServlet 是SpringMvc 是核心，它负责处理Http的请求并根据servletName-servlet.xml提供的信息去寻找处理器。 找到处理器后，调用处理器，DispatcherServlet将请求提交到Controller ，Controller 处理完逻辑代码后返回ModelandView; DispatcherServlet寻找一个或多个ViewResolver视图解析器，找到ModelandView指定的视图，最后视图负责把结果显示到客户端 一个简单的SpringMvc 部分文件结构(基于maven构建项目,不重要的就不贴了) 123456789101112131415161718192021web文件夹── web ├── WEB-INF │ ├── JSP │ ├── applicationContext.xml │ ├── css │ ├── html │ ├── images │ ├── log4j.properties │ ├── springmvc-servlet.xml │ └── web.xml └── index.jspsrc部分 ├── main │ ├── java │ │ ├── Controller │ │ ├── IndexController.java │ │ ├── LoginController.java │ │ │ │ │ └── resources 先看web.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--以上是一些名字空间命名--&gt; &lt;servlet&gt; &lt;!--这里是servlet实例的配置--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--这里是servlet实例的配置文件位置--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。取正整数表示该Servlet容器的加载优先级--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 这是路由请求映射关系，这里指的是所有请求都由sprigmvc这个servlet容器去处理--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Springmvc-servlet.xml(这是由命名规则的，servletName-servlet.xml) 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 添加了namespace还需要在schema中声明其位置 --&gt; &lt;context:component-scan base-package="Controller" /&gt; &lt;context:component-scan base-package="service" /&gt; &lt;!--这里采用基于注解的装配控制器方式--&gt; &lt;mvc:annotation-driven /&gt; &lt;!--允许所有css，html images 文件可见--&gt; &lt;!-- resource 过滤掉不需要dispatcherservlet mapping表示匹配原则--&gt; &lt;mvc:resources mapping="/css/**" location="/WEB-INF/css/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/html/**" location="WEB-INF/html/"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping="/images/**" location="WEB-INF/images/"&gt;&lt;/mvc:resources&gt; &lt;!--下面注释的两行是用xml装配控制器的代码--&gt; &lt;!--&lt;bean name="/login" class="LoginController"/&gt;--&gt; &lt;!--&lt;bean name="/register" class="RegisterController"/&gt;--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; &lt;/beans&gt; controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//引入相关的包，这里包括了注释部分需要的包@Controller//分层路由处理public class IndexController &#123; @RequestMapping("/login") //@RequestMapping("/login")完成了对/login的映射，当请求为/login时交由login函数处理 public String login()&#123; return "login"; /* 这里返回 login ，由于在xml中有声明 &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/html/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;!--这里不采用jsp,所以可以只返回 .html文件--&gt; &lt;/bean&gt; 所以实际视图解析器会去/html目录下去查找login.html文件 */ &#125; @RequestMapping("/register") public String register(HttpServletRequest request, HttpServletResponse response)&#123; // 行为参数获取请求参数 String uname = request.getParameter("uname"); String upass= request.getParameter("upass"); //code to verify //... //if not verified return "register"; //if verified //return "login";&#125; //通过@PathVariable 获取参数// @RequestMapping(value = "/register/&#123;uname&#125;/&#123;upass&#125;/",method = RequestMethod.GET)// public String register(@PathVariable String uname, @PathVariable String upass,Model model)&#123;// //code to verify// //model for jsp// return "register";// &#125; //通过@PathParam接受请求参数// @RequestMapping("/register")// public String register(@RequestParam String uname,@RequestParam String upass)&#123;// //code to verify// return "login";// &#125;// @RequestParam 和通过形式参数获取请求参数时，使用前者方式，请求参数和接收参数不一致时会返回404，而后者不会 //重定向 return "forward:/index/isLogin";// return "redirect:/index/isRegister";&#125; 小结 最近在看JavaSpring的东西，感觉Java好重，这篇就是自己回顾，感觉写的乱七八糟，关于JavaSpring的推荐去看《JavaSpring实战》 还是脚本语言写应用层后端爽，感觉Java的优势主要体现在大的项目]]></content>
      <categories>
        <category>JavaSpring</category>
      </categories>
      <tags>
        <tag>SpringMvc</tag>
        <tag>Backend</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门总结]]></title>
    <url>%2F2018%2F12%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[这是我个人学习使用Docker的知识总结，如果想要系统的学习参照官方文档 简单理解 docker是一种容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。先来一张图 docker相对于虚拟机来说要便捷许多。 docker与虚拟机的比较 特性 docker 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB级 GB级别 性能 接近原生 若弱于原生 系统容纳量 单机支持上千个容器 一般十几个 docker的结构 用一张图来表示吧 简单地说，docker存在image，container这两种东西，要跑的是container。而container是由image产生的，而image可以通过docker build 出来，也可以从远程repository pull下来。 Docker build 首先，先要建立一个Dockerfile。Dockerfile里面写的代码可以理解为创建image的一个流程，当然实际生成一个image后面有很多看不到的过程, (以搭建一个nodejs后端服务器为例): 123456789101112FROM node: version# 首先指定镜像基础，这里是构建node环境并指定版本COPY . /app # 指定工作目录WORKDIR /app# 将当前目录拷贝到images的/app目录RUN npm install --repository=https://registry.npm.taobao.org# 安装nodeJS程序的依赖EXPOSE 8008# 开放image的3000端口CMD ["node", "server.js"]# 在container运行时执行 node server.js 创建dockerfile之后，再新建.dockerignore 文件，这里主要是排除一些不要被build的文件 1234.git node_modulesnpm-debug.log# 这里主要是排除git，和nodejs的模块，需要的模块在在build的时候 RUN npm install 会自动安装 build 1docker build -t imageName path path为build的文件目录”起点“，一般是”./“ 即当前目录 Docker Run 首先我们要跑的是container，所以可以先查看有哪些container 1docker container ls Run 12345docker container run --rm -p 8080:8008 -i -t imageName /bin/bash //--rm 表示container停止后自动删除容器文件//-i 让容器的标注输入保持打开//-t 让Docker 分配一个伪终端并绑定到容器的标准输入上//-p 表示端口映射，将docker的8008端口映射到宿主机的8080端口 Docker 命令的一些细节 退出docker 1234561. docker kill containerID //结束进程，containerId的话不需要输全的，只要前四位就行啦2. dockerstop containerName//在docker 里面1. Ctrl+D 2. exit 进入Docker 12341. docker attch [option] containerId//忘记怎么使用的可以docker attch --help 2. docker exec [options] //如:进入redis, $ docker exec containerId redis-cli Docker 的一些推荐 阮一峰Docker入门教程 阮一峰Docker微服务 Docker–从入门到实践]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>Docker</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDb后端框架]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress%2F</url>
    <content type="text"><![CDATA[后端填(天)坑系列 文件结构123456789101112131415161718192021terminal: tree -L 2 -I &quot;*node_module*&quot;.├── controllers│ └── users.js├── models│ ├── blogs.js│ ├── comment.js│ └── users.js├── package-lock.json├── package.json├── routes.js├── server.js├── static│ ├── css│ ├── html│ └── images└── views ├── article.htm └── index.htm7 directories, 10 files 先看server.js ,从逻辑上来说这是服务器的入口 1234567891011121314151617181920212223242526272829303132333435363738394041// 1. require。。。。。var express = require('express');var bodyParser =require('body-parser');var cookieParser = require('cookie-parser');var expressSession = require('express-session');var mongoStore = require('connect-mongo')(&#123;session: expressSession&#125;);var mongoose =require('mongoose');/* s以上是这套后端开发常用的nodejs 库 1. express 显然是核心啦 2. body-parser, cookie-parser,express-seesion 则是一些中间件 可以把中间件理解成工具，使用中间件处理请求可以大大减少处理http请求的一些繁杂，琐碎的工作。cookie-parser，express-session,connect-mongo在登陆验证的环节会用的比较多。具体用法参见 一下链接（如果有问题，请参照官方文档） 3. mongoose 则是MongoDb的ORM(Object Relational Mapping)框架*///先编译模型require('./models/user_model.js');mongoose.connect('mongodb://localhost/dbName');var conn = mongoose.connection;//等待数据库连接完成后开始监听conn.on('open',function()&#123; var app = express(); //实例化express()对象 app.engine('.htm',require('ejs').__express); app.set('views',__dirname+'/views'); app.set('view engine','htm'); //设置模版渲染的配置 app.use(bodyParser()); app.use(cookieParser()); app.use(expressSession(&#123; secret:'SECRET', cookie:&#123;maxAge:60*60*1000&#125;, store: new mongoStore(&#123; db:mongoose.connection.db, collection:'sessions' &#125;) &#125;)); //配置插件 require('./routes')(app); //路由处理 app.listen(8008);&#125;) cookie-parser中间件实现深入剖析 express+session实现建议的身份认证 routes.js 12345678910111213141516var express =require('express');module.exports = function(app)&#123; app.use('/static',express.static('./static')); //设置静态文件的目录 app.get('/',function(req,res)&#123; res.render('index'); //render默认文件夹为view，这里是使用模版渲染的html // res.sendfile 可以返回静态文件 &#125;) /* 1.app.get('/',function(res,res)&#123;&#125;);这里处理的是GET方法的 '/'路由请求 2.express的路由处理支持正则匹配的 3.app.get('path/:id/');通过req.params.id获取参数 4.queryString可以通过req.query.Name获取 */&#125; controllers 目录是控制层一般里面放请求处理代码 123456789101112131415//一般来说路由处理通常是这样写app.get("/",function(req,res)&#123; //code to handle request &#125;)/*这样写，请求处理函数短的话没有什么问题，但是当处理函数比较复杂时，这回导致路由处理的逻辑难以分辨，不利于调试和维护。这时候就需要去耦合，减少路由分发和路由处理的耦合度*///以下面请求为例：//routes.jsvar users = require("./controllers/users")app.post('/signup',users.signup);//controllers/users.jsexport.signup = function(req,res)&#123; //code to hanlde /signup post request &#125; models—持久层目录 注意到在server.js中有一行代码： 1require('./models/user_model.js'); 这里是编译schema（我所理解的） 1234567891011121314// user_model.jsvar mongo = require('mongoose');var Schema = mongo.Schema;var UserSchema = new Schema(&#123; username:&#123;type:String,unique:true&#125;, email:String, color:String, hashed_password:String&#125;);//构建关系模型mongo.model("User",UserSchema,"User");//编译模型mongoose.model(schemaName,schema,collectionName);//如果省略第三个参数，那么会自动将第一个参数的复数形式作为作为第三个参数的值//如果该模型存在的话，就会放货这个模型 以上是我认为一个后端程序的基本结构了。有些东西一直在变化，如有问题请参照官方文档。 启动 基本的：node server.js 要知道，后端不仅仅是将程序跑起来，运维也是一个很大的问题。这里推荐使用pm2 当然，现在微服务很流行，docker也是很必要的啦！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Backend</tag>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
</search>
