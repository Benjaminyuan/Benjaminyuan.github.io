<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">








<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="读Go专家编程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="golang.md">
<meta property="og:url" content="http://yoursite.com/2020/02/23/golang/index.html">
<meta property="og:site_name" content="Benji&#39;blog">
<meta property="og:description" content="读Go专家编程笔记">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2020/02/23/images/golang_mutex_sema.png">
<meta property="og:image" content="http://yoursite.com/2020/02/23/images/golang_memory.png">
<meta property="og:image" content="http://yoursite.com/2020/02/23/images/memory-02-mspan.png">
<meta property="og:image" content="http://yoursite.com/2020/02/23/images/mcache_span.png">
<meta property="og:image" content="http://yoursite.com/2020/02/23/images/wg.png">
<meta property="og:updated_time" content="2020-05-16T04:41:12.092Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang.md">
<meta name="twitter:description" content="读Go专家编程笔记">
<meta name="twitter:image" content="http://yoursite.com/2020/02/23/images/golang_mutex_sema.png">






  <link rel="canonical" href="http://yoursite.com/2020/02/23/golang/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>golang.md | Benji'blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Benji'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">不坠青云之志</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags<span class="badge">26</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">11</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">13</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Schedule</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>Sitemap</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    
      
    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>Commonweal 404</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/golang/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BenjaminYuan">
      <meta itemprop="description" content="记录生活点滴">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Benji'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">golang.md
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-02-23 09:05:42" itemprop="dateCreated datePublished" datetime="2020-02-23T09:05:42+08:00">2020-02-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-16 12:41:12" itemprop="dateModified" datetime="2020-05-16T12:41:12+08:00">2020-05-16</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>读<a href="https://rainbo  wmango.gitbook.io/go/chapter02/2.1-defer" target="_blank" rel="noopener">Go专家编程</a>笔记<br><a id="more"></a></p>
<h1 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><ol>
<li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li>
<li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；   </li>
<li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><ol>
<li>如果等待发送队列sendq不为空，且<strong>没有缓冲区</strong>，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li>
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li>
<li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程； </li>
<li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；<h3 id="关闭chan"><a href="#关闭chan" class="headerlink" title="关闭chan"></a>关闭chan</h3></li>
</ol>
</li>
</ol>
<ul>
<li>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil</li>
<li>把sendq中的G全部唤醒，但这些G会panic<h3 id="chan类型"><a href="#chan类型" class="headerlink" title="chan类型"></a>chan类型</h3></li>
<li>加了特定限制的chan(read,write)<ul>
<li>chan 使用</li>
</ul>
</li>
<li>select with case</li>
<li>range chan</li>
</ul>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li>
<li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li>
<li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已</li>
</ul>
<h3 id="使用make创建Slice"><a href="#使用make创建Slice" class="headerlink" title="使用make创建Slice"></a>使用make创建Slice</h3><ul>
<li>使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。<h3 id="使用数组来创建Slice"><a href="#使用数组来创建Slice" class="headerlink" title="使用数组来创建Slice"></a>使用数组来创建Slice</h3></li>
<li>使用数组来创建Slice时，Slice将与原数组共用一部分内存。</li>
</ul>
<h3 id="Slice扩容"><a href="#Slice扩容" class="headerlink" title="Slice扩容"></a>Slice扩容</h3><ul>
<li>扩容实际上是<code>重新分配</code>一块更大的内存，将原Slice数据<strong>拷贝</strong>进新Slice，然后返回新Slice，扩容后再将数据追加进去。</li>
<li>扩容因子：2 or 1.25<ul>
<li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li>
<li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li>
</ul>
</li>
</ul>
<h3 id="Slice-Copy"><a href="#Slice-Copy" class="headerlink" title="Slice Copy"></a>Slice Copy</h3><ul>
<li>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取<code>两个切片长度的最小值</code>。即<code>copy过程中不会发生扩容</code>。<h3 id="编程优化"><a href="#编程优化" class="headerlink" title="编程优化"></a>编程优化</h3></li>
<li>如果扩容频繁，使用Slice提前分配容量</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler's definition.</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">	<span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">	<span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// Followed by bucketCnt keys and then bucketCnt elems.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span></span><br><span class="line">	<span class="comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span></span><br><span class="line">	<span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">	<span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个桶存储8个k/v<h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3></li>
<li><p>条件</p>
<ul>
<li>负载因子一般是：容量 / bucket数量，golang 的负载因子 loadFactorNum / loadFactorDen = 6.5</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li>
</ul>
</li>
<li><p>渐渐式迁移，把key的迁移分摊到每次插入或者删除，每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
</li>
</ul>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><ul>
<li>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3></li>
</ul>
<ol>
<li>根据key值算出哈希值 </li>
<li>取哈希值低位与hmap.B取模确定bucket位置 </li>
<li>取哈希值高位在tophash数组中查询 </li>
<li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较 </li>
<li>当前bucket没有找到，则继续从下个overflow的bucket中查找。 6. 如果当前处于搬迁过程，则优先从oldbuckets查找<h2 id="Tag的本质"><a href="#Tag的本质" class="headerlink" title="Tag的本质"></a>Tag的本质</h2><h3 id="Tag规则"><a href="#Tag规则" class="headerlink" title="Tag规则"></a>Tag规则</h3></li>
</ol>
<ul>
<li>Tag本身是一个字符串，但字符串中却是： <code>以空格分隔的 key:value 对</code>。</li>
</ul>
<h3 id="Tag是Struct的一部分"><a href="#Tag是Struct的一部分" class="headerlink" title="Tag是Struct的一部分"></a>Tag是Struct的一部分</h3><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>iota常用于const表达式中，我们还知道其值是从零开始，const声明块中每增加一行iota值自增1，<code>iota代表了const声明块的行索引（下标从0开始）</code></li>
</ul>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>string是8比特字节的集合，通常是但并不一定非得是UTF-8编码的文本。<h3 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h3></li>
<li><p>byte切片可以很方便的转换成string,<code>这种转换需要一次内存拷贝</code></p>
<ul>
<li>跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)</li>
<li>构建string（string.str = p；string.len = len；） </li>
<li>拷贝数据(切片中数据拷贝到新申请的内存空间)<h3 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h3></li>
</ul>
</li>
<li><p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p>
<ul>
<li>申请切片内存空间</li>
<li>将string拷贝到切片</li>
</ul>
</li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li><p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的<code>内存空间是一次分配完成</code>的，所以性能消耗主要在拷贝数据上</p>
<h3 id="go语言字符串不允许修改"><a href="#go语言字符串不允许修改" class="headerlink" title="go语言字符串不允许修改"></a>go语言字符串不允许修改</h3></li>
<li><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝</p>
</li>
<li>因为string通常指向字符串字面量，而字符串字面量存储位置是<code>只读段</code>，而不是堆或栈上，所以才有了string不可修改的约定</li>
</ul>
<h1 id="控制关键字"><a href="#控制关键字" class="headerlink" title="控制关键字"></a>控制关键字</h1><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp      <span class="keyword">uintptr</span>   <span class="comment">//函数栈指针</span></span><br><span class="line">    pc      <span class="keyword">uintptr</span>   <span class="comment">//程序计数器</span></span><br><span class="line">    fn      *funcval  <span class="comment">//函数地址</span></span><br><span class="line">    link    *_defer   <span class="comment">//指向自身结构的指针，用于链接多个defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer<code>插入到单链表表头</code>(deferproc()函数)，每次执行defer时就从<code>单链表表头取出</code>一个defer执行(deferreturn)。<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3></li>
<li>defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前再把延迟的函数取出并执行<h3 id="defer三个原则"><a href="#defer三个原则" class="headerlink" title="defer三个原则"></a>defer三个原则</h3></li>
<li>延迟函数fmt.Println(aInt)的参数在defer语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数</li>
<li>延迟函数执行按后进先出顺序执行，即先出现的defer最后执行,延迟函数执行时机是在<code>return语句之前</code></li>
<li>延迟函数可能操作主函数的具名返回值: 拥有defer的函数返回过程是：<code>设置返回值</code>–&gt;<code>执行defer</code>–&gt;<code>ret</code>。<h3 id="defer使用recover-函数问题"><a href="#defer使用recover-函数问题" class="headerlink" title="defer使用recover()函数问题"></a>defer使用recover()函数问题</h3>以下三个条件会让recover()返回nil:<ol>
<li>panic时指定的参数为nil；（一般panic语句如panic(“xxx failed…”)） </li>
<li>当前协程没有发生panic； </li>
<li>recover<code>没有被defer方法直接调用</code>；</li>
</ol>
</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready(即是否可读或可写)。</li>
<li>select中各个case执行顺序是随机的，如果某个case中的channel已经ready，则执行相应的语句并退出select流程<h3 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">    c           *hchan         <span class="comment">// chan</span></span><br><span class="line">    kind        <span class="keyword">uint16</span>         <span class="comment">// scase.kind表示该case的类型，分为读channel、写channel和default</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// data element,表示（读写）出channel的数据存放地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select选择case函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数参数：</p>
<ul>
<li>cas0为scase数组的首地址，selectgo()就是从这些scase中找出一个返回。<br>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder           </li>
<li>pollorder：每次selectgo执行都会把scase序列打乱，以达到随机检测case的目的。        </li>
<li>lockorder：所有case语句中channel序列，以达到去重防止对channel加锁时重复加锁的目的。</li>
<li>ncases表示scase数组的长度</li>
</ul>
</li>
<li><p>代码逻辑</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 锁定scase语句中所有的channel</span></span><br><span class="line">    <span class="comment">//2. 按照随机顺序检测scase中的channel是否ready</span></span><br><span class="line">    <span class="comment">//   2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true)</span></span><br><span class="line">    <span class="comment">//   2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false)</span></span><br><span class="line">    <span class="comment">//   2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false）</span></span><br><span class="line">    <span class="comment">//3. 所有case都未ready，且没有default语句</span></span><br><span class="line">    <span class="comment">//   3.1 将当前协程加入到所有channel的等待队列</span></span><br><span class="line">    <span class="comment">//   3.2 当将协程转入阻塞，等待被唤醒</span></span><br><span class="line">    <span class="comment">//4. 唤醒后返回channel对应的case index</span></span><br><span class="line">    <span class="comment">//   4.1 如果是读操作，解锁所有的channel，然后返回(case index, true)</span></span><br><span class="line">    <span class="comment">//   4.2 如果是写操作，解锁所有的channel，然后返回(case index, false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map、channel等</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。</li>
<li>使用index,value接收range返回值会发生一次数据拷贝</li>
</ul>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><h3 id="数据结构-6"><a href="#数据结构-6" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span> <span class="comment">//表示互斥锁的状态，比如是否被锁定等</span></span><br><span class="line">    sema  <span class="keyword">uint32</span> <span class="comment">// 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。<br><img src="../images/golang_mutex_sema.png" alt=""><ul>
<li>Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定</li>
<li>表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。</li>
<li>表示该Mutex是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。</li>
<li>表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。 </li>
<li>协程之间抢锁实际上是抢给Locked赋值的权利，能给Locked域置1<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3></li>
</ul>
</li>
<li>Lock()</li>
<li>Unlock()<h3 id="加解锁过程"><a href="#加解锁过程" class="headerlink" title="加解锁过程"></a>加解锁过程</h3></li>
<li>加锁：如果没有被locked，直接修改locked的值，否则Waiter计数器增加了1，协程被阻塞</li>
<li>解锁：一是把Locked位置0，二是查看到Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked位置1，于是协程B获得锁。<h3 id="自旋转锁"><a href="#自旋转锁" class="headerlink" title="自旋转锁"></a>自旋转锁</h3></li>
<li>加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程</li>
<li>自旋条件<ul>
<li>自旋次数要足够小，通常为4，即自旋最多4次</li>
<li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁</li>
<li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋</li>
<li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度<h3 id="自旋的问题"><a href="#自旋的问题" class="headerlink" title="自旋的问题"></a>自旋的问题</h3></li>
</ul>
</li>
<li>自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。<h3 id="Mutex模式"><a href="#Mutex模式" class="headerlink" title="Mutex模式"></a>Mutex模式</h3></li>
<li>normal模式<ul>
<li>协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁</li>
</ul>
</li>
<li>starvation模式<ul>
<li>自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</li>
<li>处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。<h3 id="woken状态"><a href="#woken状态" class="headerlink" title="woken状态"></a>woken状态</h3></li>
</ul>
</li>
<li>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</li>
</ul>
<h3 id="重复解锁要panic"><a href="#重复解锁要panic" class="headerlink" title="重复解锁要panic"></a>重复解锁要panic</h3><ul>
<li>如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</li>
</ul>
<h3 id="编程Tips"><a href="#编程Tips" class="headerlink" title="编程Tips"></a>编程Tips</h3><ul>
<li>使用defer解锁         </li>
<li>加锁，解锁应该成对出现     </li>
</ul>
<h2 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h2><h3 id="数据结构-7"><a href="#数据结构-7" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rwmutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	rLock      mutex    <span class="comment">// protects readers, readerPass, writer</span></span><br><span class="line">	readers    muintptr <span class="comment">// list of pending readers</span></span><br><span class="line">	readerPass <span class="keyword">uint32</span>   <span class="comment">// number of pending readers to skip readers list</span></span><br><span class="line"></span><br><span class="line">	wLock  mutex    <span class="comment">// serializes writers</span></span><br><span class="line">	writer muintptr <span class="comment">// pending writer waiting for completing readers</span></span><br><span class="line"></span><br><span class="line">	readerCount <span class="keyword">uint32</span> <span class="comment">// number of pending readers</span></span><br><span class="line">	readerWait  <span class="keyword">uint32</span> <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读锁定"><a href="#读锁定" class="headerlink" title="读锁定"></a>读锁定</h3><ul>
<li>写操作将readerCount变成负值来阻止读操作的，读操作通过readerCount+1来将来阻止写操作的。<h3 id="为什么写锁定不会被饿死"><a href="#为什么写锁定不会被饿死" class="headerlink" title="为什么写锁定不会被饿死"></a>为什么写锁定不会被饿死</h3></li>
<li>写操作到来时，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记排在写操作前面的读者个数。</li>
<li>前面的读操作结束后，除了会递减RWMutex.readerCount，还会<code>递减RWMutex.readerWait值</code>，当RWMutex.readerWait值变为0时唤醒写操作</li>
</ul>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h2 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h2><ul>
<li>GMP，可看另外一篇博客文章<a href="https://draveness.me/system-design-scheduler" target="_blank" rel="noopener">调度系统设计</a><h3 id="队列轮转"><a href="#队列轮转" class="headerlink" title="队列轮转"></a>队列轮转</h3></li>
<li>每个P维护的G队列以外，还有一个全局的队列，每个P会<code>周期性</code>地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3></li>
<li>当M即将进入系统调用时，P会与该M解除绑定</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul>
<li>C语言程序通过malloc()方法动态申请内存，其中内存分配器使用的是glibc提供的ptmalloc2。除了glibc，业界比较出名的内存分配器有Google的tcmalloc和Facebook的jemalloc。二者在避免内存碎片和性能上均比glibc有比较大的优势，在多线程环境中效果更明显</li>
<li>Golang预申请的内存划分为spans、bitmap、arena三部分。其中arena即为所谓的堆区，应用中需要的内存从这里分配。其中spans和bitmap是为了管理arena区而存在的。<ul>
<li>arena的大小为512G，为了方便管理把arena区域划分成一个个的page，<code>每个page为8KB</code>,一共有<code>512GB/8KB个页</code>；</li>
<li>spans区域存放span的指针，每个指针对应一个或多个page，所以span区域的大小为(512GB/8KB)*指针大小8byte = 512M</li>
<li>bitmap区域大小也是通过arena计算出来，不过主要用于GC。<br><img src="../images/golang_memory.png" alt=""><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3></li>
</ul>
</li>
<li>span是用于管理arena页的关键数据结构，每个span中包含1个或多个连续页，为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现。</li>
<li>根据对象大小，划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小。<h4 id="span数据结构"><a href="#span数据结构" class="headerlink" title="span数据结构"></a>span数据结构</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan            <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    prev *mspan            <span class="comment">//链表前向指针，用于将span链接起来</span></span><br><span class="line">    startAddr <span class="keyword">uintptr</span> <span class="comment">// 起始地址，也即所管理页的地址</span></span><br><span class="line">    npages    <span class="keyword">uintptr</span> <span class="comment">// 管理的页数</span></span><br><span class="line"></span><br><span class="line">    nelems <span class="keyword">uintptr</span> <span class="comment">// 块个数，也即有多少个块可供分配</span></span><br><span class="line"></span><br><span class="line">    allocBits  *gcBits <span class="comment">//分配位图，每一位代表一个块是否已分配</span></span><br><span class="line"></span><br><span class="line">    allocCount  <span class="keyword">uint16</span>     <span class="comment">// 已分配块的个数</span></span><br><span class="line">    spanclass   spanClass  <span class="comment">// class表中的class ID</span></span><br><span class="line"></span><br><span class="line">    elemsize    <span class="keyword">uintptr</span>    <span class="comment">// class表中的对象大小，也即块大小</span></span><br><span class="line">    <span class="comment">//还有字段省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="../images/memory-02-mspan.png" alt=""></p>
<ul>
<li>allocBits指向一个位图，每位代表一个块是否被分配，本例中有两个块已经被分配，其allocCount也为2</li>
<li><p>next和prev用于将多个span链接起来，这有利于管理多个span</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [<span class="number">67</span>*<span class="number">2</span>]*mspan <span class="comment">// 按class分组的mspan列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了避免多线程申请内存时不断的加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache,各线程需要内存时从mcentral管理的span中申请内存</p>
</li>
<li>每种class类型都有两组span列表，第一组列表中所表示的对象中包含了指针，第二组列表中所表示的对象不含有指针，这么做是为了提高GC扫描性能，对于不包含指针的span列表，没必要去扫描</li>
<li>根据对象是否包含指针，将对象分为noscan和scan两类，其中noscan代表没有指针，而scan则代表有指针，需要GC进行扫描。<br><img src="../images/mcache_span.png" alt=""><h3 id="central"><a href="#central" class="headerlink" title="central"></a>central</h3></li>
<li><p>cache作为线程的私有资源为单个线程服务，而central则是全局资源，为多个线程服务，当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex     <span class="comment">//互斥锁</span></span><br><span class="line">    spanclass spanClass <span class="comment">// span class ID</span></span><br><span class="line">    nonempty  mSpanList <span class="comment">// non-empty 指还有空闲块的span列表</span></span><br><span class="line">    empty     mSpanList <span class="comment">// 指没有空闲块的span列表</span></span><br><span class="line"></span><br><span class="line">    nmalloc <span class="keyword">uint64</span>      <span class="comment">// 已累计分配的对象个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程从central获取span步骤如下： </p>
<ol>
<li>加锁 </li>
<li>从nonempty列表获取一个可用span，并将其从链表中删除 </li>
<li>将取出的span放入empty链表 </li>
<li>将span返回给线程 </li>
<li>解锁 </li>
<li>线程将该span缓存进cache</li>
</ol>
</li>
<li><p>线程将span归还步骤如下： </p>
<ol>
<li>加锁 </li>
<li>将span从empty列表删除 </li>
<li>将span加入noneempty列表 </li>
<li>解锁<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex</span><br><span class="line">    spans []*mspan</span><br><span class="line">    bitmap        <span class="keyword">uintptr</span>     <span class="comment">//指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">    arena_start <span class="keyword">uintptr</span>        <span class="comment">//指示arena区首地址</span></span><br><span class="line">    arena_used  <span class="keyword">uintptr</span>        <span class="comment">//指示arena区已使用地址位置</span></span><br><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>lock： 互斥锁</p>
</li>
<li>spans: 指向spans区域，用于映射span和page的关系</li>
<li>bitmap：bitmap的起始地址</li>
<li>arena_start: arena区域首地址</li>
<li>arena_used: 当前arena已使用区域的最大地址</li>
<li>central: 每种class对应的两个mcentral<blockquote>
<p>系统预分配的内存分为spans、bitmap、arean三个区域，通过mheap管理起来。接下来看内存分配过程</p>
</blockquote>
<h3 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h3></li>
<li>以申请size为n的内存为例，分配步骤如下： <ol>
<li>获取当前线程的私有缓存mcache </li>
<li>跟据size计算出适合的class的ID </li>
<li>从mcache的alloc[class]链表中查询可用的span </li>
<li>如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中 </li>
<li>如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral </li>
<li>从该span中获取到空闲对象地址并返回</li>
</ol>
</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="业界常见的垃圾回收算法有以下几种："><a href="#业界常见的垃圾回收算法有以下几种：" class="headerlink" title="业界常见的垃圾回收算法有以下几种："></a>业界常见的垃圾回收算法有以下几种：</h3><ul>
<li>引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。<ul>
<li>优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阀值时才回收。</li>
<li>缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价。</li>
<li>代表语言：Python、PHP、Swift</li>
</ul>
</li>
<li>标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。<ul>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要STW，即要暂时停掉程序运行。</li>
<li>代表语言：<code>Golang（其采用三色标记法）</code></li>
</ul>
</li>
<li>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率。<ul>
<li>优点：回收性能好</li>
<li>缺点：算法复杂</li>
<li>代表语言： JAVA</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收优化"><a href="#垃圾回收优化" class="headerlink" title="垃圾回收优化"></a>垃圾回收优化</h3><ul>
<li>写屏障(Write Barrier)<ul>
<li>写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定，Java中是维护卡表。</li>
<li>GC过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即GC过程中分配的内存不会在本轮GC中回收。</li>
</ul>
</li>
<li>辅助GC(Mutator Assist)<ul>
<li>为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。<h3 id="内存回收时机"><a href="#内存回收时机" class="headerlink" title="内存回收时机"></a>内存回收时机</h3><h4 id="内存分配量达到阀值触发GC"><a href="#内存分配量达到阀值触发GC" class="headerlink" title="内存分配量达到阀值触发GC"></a>内存分配量达到阀值触发GC</h4></li>
</ul>
</li>
<li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动GC。<br><code>阀值 = 上次GC内存分配量 * 内存增长率</code></li>
<li>内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC  <h3 id="定期触发GC"><a href="#定期触发GC" class="headerlink" title="定期触发GC"></a>定期触发GC</h3></li>
<li>默认情况下，最长2分钟触发一次GC<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3></li>
<li>程序代码中也可以使用runtime.GC()来手动触发GC。这主要用于GC性能测试和统计。</li>
</ul>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h3 id="逃逸分析策略"><a href="#逃逸分析策略" class="headerlink" title="逃逸分析策略"></a>逃逸分析策略</h3><ul>
<li>每当函数中申请新的对象，编译器会跟据该对象是否被函数外部引用来决定是否逃逸： <ol>
<li>如果函数外部没有引用，则优先放到栈中； </li>
<li>如果函数外部存在引用，则必定放到堆中；</li>
<li>对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</li>
</ol>
</li>
</ul>
<h3 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h3><h4 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h4><ul>
<li>返回局部变量指针<h4 id="栈空间不足逃逸"><a href="#栈空间不足逃逸" class="headerlink" title="栈空间不足逃逸"></a>栈空间不足逃逸</h4></li>
<li>切片长度过大<h4 id="动态类型逃逸"><a href="#动态类型逃逸" class="headerlink" title="动态类型逃逸"></a>动态类型逃逸</h4><h4 id="闭包引用对象逃逸"><a href="#闭包引用对象逃逸" class="headerlink" title="闭包引用对象逃逸"></a>闭包引用对象逃逸</h4></li>
</ul>
<h1 id="协程控制"><a href="#协程控制" class="headerlink" title="协程控制"></a>协程控制</h1><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h2 id="waitgroup"><a href="#waitgroup" class="headerlink" title="waitgroup"></a>waitgroup</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">	<span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">	<span class="comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span></span><br><span class="line">	<span class="comment">// for the sema.</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>counter： 当前还未执行结束的goroutine计数器   </li>
<li>waiter count: 等待goroutine-group结束的</li>
<li>goroutine数量，即有多少个等候者</li>
<li>semaphore: 信号量<br><img src="../images/wg.png" alt=""></li>
</ul>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Deadline()<ul>
<li>该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok == false，此时deadline为一个初始值的time.Time值</li>
</ul>
</li>
<li>Done()<ul>
<li>该方法返回一个channel，需要在select-case语句中使用，如”case &lt;-context.Done():”。当context关闭后，Done()返回一个被关闭的管道，关闭的管道仍然是可读的，据此goroutine可以收到关闭请求； 当context还未关闭时，<strong>Done()返回nil</strong>。</li>
</ul>
</li>
<li>Err()<ul>
<li>该方法描述context关闭的原因。关闭原因由context实现控制，不需要用户设置。比如Deadline context，关闭原因可能是因为deadline，也可能提前被主动关闭，那么关闭原因就会不同:<ul>
<li>因deadline关闭：“context deadline exceeded”；</li>
<li>因主动关闭： “context canceled”。</li>
</ul>
</li>
<li>当context关闭后，Err()返回context的关闭原因； 当context还未关闭时，Err()返回nil；</li>
</ul>
</li>
<li>Value()<ul>
<li>用于在树状分布的goroutine间传递信息。<h3 id="官方包中几个常用的context"><a href="#官方包中几个常用的context" class="headerlink" title="官方包中几个常用的context"></a>官方包中几个常用的context</h3><h4 id="空Context"><a href="#空Context" class="headerlink" title="空Context"></a>空Context</h4></li>
</ul>
</li>
<li>context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于<code>其他context的父节点</code><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><ul>
<li><p>数据结构</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>children中记录了由此context派生的所有child，此context被cancel时会把其中的所有child都cancel掉。</p>
</li>
<li>cancelCtx与deadline和value无关，所以只需要实现Done()和Err()外露接口即可。</li>
<li><p>Done()接口实现</p>
<ul>
<li>按照Context定义，Done()接口只需要返回一个channel即可，对于cancelCtx来说只需要返回成员变量done即可。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  d := c.done</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Err()接口实现</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  err := c.err</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cancel()接口实现</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line"></span><br><span class="line">  c.err = err                          <span class="comment">//设置一个error，说明关闭原因</span></span><br><span class="line">  <span class="built_in">close</span>(c.done)                     <span class="comment">//将channel关闭，以此通知派生的context</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;   <span class="comment">//遍历所有children，逐个调用cancel方法</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  c.children = <span class="literal">nil</span></span><br><span class="line">  c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> removeFromParent &#123;            <span class="comment">//正常情况下，需要将自己从parent删除</span></span><br><span class="line">      removeChild(c.Context, c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WithCancel</p>
<ul>
<li>初始化一个cancelCtx实例</li>
<li>将cancelCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)<ul>
<li>如果父节点也支持cancel，也就是说其父节点肯定有children成员，那么把新context添加到children里即可； </li>
<li>如果父节点不支持cancel，就继续向上查询，直到找到一个支持cancel的节点，把新context添加到children里；</li>
<li>如果所有的父节点均不支持cancel，则启动一个协程等待父节点结束，然后再把当前context结束。</li>
</ul>
</li>
<li>返回cancelCtx实例和cancel()方法<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">  c := newCancelCtx(parent)</span><br><span class="line">  propagateCancel(parent, &amp;c)   <span class="comment">//将自身添加到父节点</span></span><br><span class="line">  <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>timerCtx在cancelCtx基础上增加了deadline用于标示自动cancel的最终时间，而timer就是一个触发自动cancel的定时器。<h4 id="Deadline-接口实现"><a href="#Deadline-接口实现" class="headerlink" title="Deadline()接口实现"></a>Deadline()接口实现</h4></li>
</ul>

      
    </div>

    

    
    
    

    

    
       
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>谢谢你请我吃糖果</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="BenjaminYuan WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="BenjaminYuan Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/09/design-patterns/" rel="next" title="design_patterns">
                <i class="fa fa-chevron-left"></i> design_patterns
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/15/system_design/" rel="prev" title="system_design">
                system_design <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="BenjaminYuan">
            
              <p class="site-author-name" itemprop="name">BenjaminYuan</p>
              <p class="site-description motion-element" itemprop="description">记录生活点滴</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/Benjaminyuan" title="GitHub &rarr; https://github.com/Benjaminyuan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#常见数据结构"><span class="nav-number">1.</span> <span class="nav-text">常见数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">1.1.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写数据"><span class="nav-number">1.1.2.</span> <span class="nav-text">写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读数据"><span class="nav-number">1.1.3.</span> <span class="nav-text">读数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭chan"><span class="nav-number">1.1.4.</span> <span class="nav-text">关闭chan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chan类型"><span class="nav-number">1.1.5.</span> <span class="nav-text">chan类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice"><span class="nav-number">1.2.</span> <span class="nav-text">slice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用make创建Slice"><span class="nav-number">1.2.2.</span> <span class="nav-text">使用make创建Slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用数组来创建Slice"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用数组来创建Slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slice扩容"><span class="nav-number">1.2.4.</span> <span class="nav-text">Slice扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slice-Copy"><span class="nav-number">1.2.5.</span> <span class="nav-text">Slice Copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程优化"><span class="nav-number">1.2.6.</span> <span class="nav-text">编程优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">1.3.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增量扩容"><span class="nav-number">1.3.2.</span> <span class="nav-text">增量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等量扩容"><span class="nav-number">1.3.3.</span> <span class="nav-text">等量扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找过程"><span class="nav-number">1.3.4.</span> <span class="nav-text">查找过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tag的本质"><span class="nav-number">1.4.</span> <span class="nav-text">Tag的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag规则"><span class="nav-number">1.4.1.</span> <span class="nav-text">Tag规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag是Struct的一部分"><span class="nav-number">1.4.2.</span> <span class="nav-text">Tag是Struct的一部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iota"><span class="nav-number">1.5.</span> <span class="nav-text">iota</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">1.6.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-3"><span class="nav-number">1.6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.6.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#byte转string"><span class="nav-number">1.6.3.</span> <span class="nav-text">[]byte转string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string转-byte"><span class="nav-number">1.6.4.</span> <span class="nav-text">string转[]byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串拼接"><span class="nav-number">1.6.5.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go语言字符串不允许修改"><span class="nav-number">1.6.6.</span> <span class="nav-text">go语言字符串不允许修改</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制关键字"><span class="nav-number">2.</span> <span class="nav-text">控制关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">2.1.</span> <span class="nav-text">defer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-4"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer三个原则"><span class="nav-number">2.1.3.</span> <span class="nav-text">defer三个原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer使用recover-函数问题"><span class="nav-number">2.1.4.</span> <span class="nav-text">defer使用recover()函数问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select"><span class="nav-number">2.2.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-5"><span class="nav-number">2.2.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现逻辑"><span class="nav-number">2.2.3.</span> <span class="nav-text">实现逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#range"><span class="nav-number">2.3.</span> <span class="nav-text">range</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-number">2.3.2.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex"><span class="nav-number">2.4.</span> <span class="nav-text">Mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-6"><span class="nav-number">2.4.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">2.4.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加解锁过程"><span class="nav-number">2.4.3.</span> <span class="nav-text">加解锁过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋转锁"><span class="nav-number">2.4.4.</span> <span class="nav-text">自旋转锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋的问题"><span class="nav-number">2.4.5.</span> <span class="nav-text">自旋的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex模式"><span class="nav-number">2.4.6.</span> <span class="nav-text">Mutex模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#woken状态"><span class="nav-number">2.4.7.</span> <span class="nav-text">woken状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复解锁要panic"><span class="nav-number">2.4.8.</span> <span class="nav-text">重复解锁要panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程Tips"><span class="nav-number">2.4.9.</span> <span class="nav-text">编程Tips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWMutex"><span class="nav-number">2.5.</span> <span class="nav-text">RWMutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-7"><span class="nav-number">2.5.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁定"><span class="nav-number">2.5.2.</span> <span class="nav-text">读锁定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么写锁定不会被饿死"><span class="nav-number">2.5.3.</span> <span class="nav-text">为什么写锁定不会被饿死</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程"><span class="nav-number">3.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#调度机制"><span class="nav-number">3.1.</span> <span class="nav-text">调度机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#队列轮转"><span class="nav-number">3.1.1.</span> <span class="nav-text">队列轮转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用"><span class="nav-number">3.1.2.</span> <span class="nav-text">系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配"><span class="nav-number">4.1.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-3"><span class="nav-number">4.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#span"><span class="nav-number">4.1.2.</span> <span class="nav-text">span</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#span数据结构"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">span数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache"><span class="nav-number">4.1.3.</span> <span class="nav-text">cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#central"><span class="nav-number">4.1.4.</span> <span class="nav-text">central</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap"><span class="nav-number">4.1.5.</span> <span class="nav-text">heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配过程"><span class="nav-number">4.1.6.</span> <span class="nav-text">内存分配过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-number">4.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#业界常见的垃圾回收算法有以下几种："><span class="nav-number">4.2.1.</span> <span class="nav-text">业界常见的垃圾回收算法有以下几种：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收优化"><span class="nav-number">4.2.2.</span> <span class="nav-text">垃圾回收优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存回收时机"><span class="nav-number">4.2.3.</span> <span class="nav-text">内存回收时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配量达到阀值触发GC"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">内存分配量达到阀值触发GC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定期触发GC"><span class="nav-number">4.2.4.</span> <span class="nav-text">定期触发GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手动触发"><span class="nav-number">4.2.5.</span> <span class="nav-text">手动触发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逃逸分析"><span class="nav-number">4.3.</span> <span class="nav-text">逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逃逸分析策略"><span class="nav-number">4.3.1.</span> <span class="nav-text">逃逸分析策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逃逸场景"><span class="nav-number">4.3.2.</span> <span class="nav-text">逃逸场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指针逃逸"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">指针逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈空间不足逃逸"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">栈空间不足逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态类型逃逸"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">动态类型逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包引用对象逃逸"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">闭包引用对象逃逸</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程控制"><span class="nav-number">5.</span> <span class="nav-text">协程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#channel"><span class="nav-number">5.1.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitgroup"><span class="nav-number">5.2.</span> <span class="nav-text">waitgroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context"><span class="nav-number">5.3.</span> <span class="nav-text">Context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#官方包中几个常用的context"><span class="nav-number">5.3.1.</span> <span class="nav-text">官方包中几个常用的context</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空Context"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">空Context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cancelCtx"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">cancelCtx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timerCtx"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">timerCtx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deadline-接口实现"><span class="nav-number">5.3.1.4.</span> <span class="nav-text">Deadline()接口实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BenjaminYuan</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>


  

</body>
<script type="text/javascript" src="/js/src/clicklove.js"></script>
</html>
